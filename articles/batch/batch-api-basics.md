---
title: 開発者向け Azure Batch の概要 | Microsoft Docs
description: 開発の観点から、Batch サービスとその API の機能について説明します。
services: batch
documentationcenter: .net
author: dlepow
manager: jeconnoc
editor: ''
ms.assetid: 416b95f8-2d7b-4111-8012-679b0f60d204
ms.service: batch
ms.devlang: multiple
ms.topic: get-started-article
ms.tgt_pltfrm: na
ms.workload: big-compute
ms.date: 04/06/2018
ms.author: danlep
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: d404e3a300a953ccc1cfb691cbde6f6d7ee54b26
ms.sourcegitcommit: 248c2a76b0ab8c3b883326422e33c61bd2735c6c
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/23/2018
ms.locfileid: "39216310"
---
# <a name="develop-large-scale-parallel-compute-solutions-with-batch"></a>Batch を使って大規模な並列コンピューティング ソリューションを開発する

ここでは、Azure Batch サービスの主要コンポーネントについて簡単に紹介し、Batch を使って大規模な並列コンピューティング ソリューションを開発する際に利用できる主な機能とリソースについて取り上げます。

[REST API][batch_rest_api] を直接呼び出す分散コンピューティング アプリケーションまたはサービスを開発する場合も、いずれかの [Batch SDK](batch-apis-tools.md#azure-accounts-for-batch-development) を使う場合も、この記事で紹介するさまざまなリソースや機能を活用することができます。

> [!TIP]
> Batch サービスの基本については、「 [Azure Batch の基礎](batch-technical-overview.md)」を参照してください。 また、最新の [Batch サービスの更新](https://azure.microsoft.com/updates/?product=batch)も参照してください。
>
>

## <a name="batch-service-workflow"></a>Batch サービスのワークフロー
以下に示したのは、Batch サービスを使って並列ワークロードを処理するアプリケーションやサービスでほぼ例外なく使用する基本的なワークフローです。

1. 処理対象の**データ ファイル**を [Azure Storage][azure_storage] アカウントにアップロードします。 Batch には、Azure Blob Storage へのアクセスのサポートが組み込まれており、これらのファイルは、タスクの実行時に [コンピューティング ノード](#compute-node) にダウンロードすることができます。
2. タスクで実行する**アプリケーション ファイル**をアップロードします。 たとえばジョブのタスクによって実行されるバイナリやスクリプト、さらには、その依存関係をアップロードできます。 これらのファイルは、タスクによって Storage アカウントからダウンロードできます。また、Batch の[アプリケーション パッケージ](#application-packages)機能をアプリケーションの管理とデプロイに利用することもできます。
3. コンピューティング ノードの [プール](#pool) を作成します。 プールを作成するときに、プールのコンピューティング ノードの数とサイズ、オペレーティング システムを指定します。 ジョブに含まれる各タスクは、その実行時に、プール内のいずれかのノードで実行されるように割り当てられます。
4. [ジョブ](#job)を作成します。 ジョブはタスクのコレクションを管理するものです。 各ジョブは、ジョブのタスクの実行場所とする特定のプールに関連付けて使用します。
5. ジョブに [タスク](#task) を追加します。 各タスクは、アップロードされたアプリケーション (またはスクリプト) を実行し、ストレージ アカウントからダウンロードしたデータ ファイルを処理します。 完了した各タスクは、その出力を Azure Storage にアップロードすることができます。
6. ジョブの進行状況を監視し、タスクの出力を Azure Storage から取得します。

次のセクションでは、これ以外にも、分散コンピューティングのシナリオを実現する Batch の各種リソースについて説明します。

> [!NOTE]
> Batch サービスを利用するには、[Batch アカウント](#account)が必要です。 また、ほとんどの Batch ソリューションでは、関連付けられている [Azure Storage][azure_storage] アカウントがファイルの格納と取得に使用されています。 
>
>

## <a name="batch-service-resources"></a>Batch サービスのリソース
以下に示すリソースのいくつか (アカウント、コンピューティング ノード、プール、ジョブ、タスク) は、Batch サービスを使用するすべてのソリューションで必須となります。 ジョブ スケジュールやアプリケーション パッケージなど、有用ながらオプションの機能もあります。

* [アカウント](#account)
* [コンピューティング ノード](#compute-node)
* [プール](#pool)
* [ジョブ](#job)
  * [ジョブ スケジュール](#scheduled-jobs)
* [タスク](#task)
  * [開始タスク](#start-task)
  * [ジョブ マネージャー タスク](#job-manager-task)
  * [ジョブ準備タスクおよびジョブ解放タスク](#job-preparation-and-release-tasks)
  * [マルチインスタンス タスク (MPI)](#multi-instance-tasks)
  * [Task dependencies](#task-dependencies)
* [アプリケーション パッケージ](#application-packages)

## <a name="account"></a>Account
Batch アカウントは、Batch サービス内で一意に識別されるエンティティです。 すべての処理は、Batch アカウントに関連付けられています。

Azure Batch アカウントは、[Azure Portal](batch-account-create-portal.md) またはプログラム ([Batch Management .NET ライブラリ](batch-management-dotnet.md)など) を使用して作成できます。 アカウントを作成する際に、ジョブに関する入出力データまたはアプリケーションの格納に使用する、Azure ストレージ アカウントを関連付けることができます。

1 つの Batch アカウントで複数の Batch ワークロードを実行することも、同じサブスクリプションで異なる Azure リージョンの複数の Batch アカウントにワークロードを分散することもできます。

[!INCLUDE [batch-account-mode-include](../../includes/batch-account-mode-include.md)]

## <a name="azure-storage-account"></a>Azure ストレージ アカウント

ほとんどの Batch ソリューションでは、リソース ファイルまたは出力ファイルを格納するために Azure Storage を使用します。 たとえば、Batch タスク (標準タスク、開始タスク、ジョブ準備タスク、ジョブ解放タスクなど) では通常、ストレージ アカウントに存在するリソース ファイルを指定します。

Batch では、次の Azure ストレージ [アカウント オプション](../storage/common/storage-account-options.md)がサポートされます。

* 汎用 v2 (GPv2) アカウント 
* 汎用 v1 (GPv1) アカウント
* BLOB ストレージ アカウント (現在、仮想マシン構成のプールに対してのみサポートされます)

ストレージ アカウントは、Batch アカウントの作成時に (または後で) Batch アカウントに関連付けることができます。 ストレージ アカウントを選択するときに、コストとパフォーマンスの要件を検討してください。 たとえば、GPv2 アカウントおよび BLOB ストレージ アカウントのオプションでは、サポートされる[容量とスケーラビリティの上限](https://azure.microsoft.com/blog/announcing-larger-higher-scale-storage-accounts/)が GPv1 よりも高くなっています  (容量の上限の引き上げを希望する場合、Azure サポートにお問い合わせください)。これらのアカウント オプションでは、ストレージ アカウントからの読み取りまたはストレージ アカウントへの書き込みを行う多数の並列タスクが含まれた、Batch ソリューションのパフォーマンスを向上させることができます。

## <a name="compute-node"></a>コンピューティング ノード
コンピューティング ノードは、アプリケーションの一部のワークロードの処理に特化した Azure 仮想マシン (VM) またはクラウド サービス VM です。 ノードのサイズによって、CPU コアの数、メモリ容量、およびノードに割り当てられるローカル ファイル システムのサイズが決まります。 Azure Cloud Services か、[Azure Virtual Machines Marketplace][vm_marketplace] のイメージを使用して Windows ノードまたは Linux ノードのプールを作成することができます。 これらの各オプションの詳細については、以下の「 [プール](#pool) 」セクションを参照してください。

ノードは、そのオペレーティング システム環境が対応していれば、どのような実行可能ファイル (またはスクリプト) でも実行できます。 たとえば、Windows なら \*.exe、\*.cmd、\*.bat、PowerShell スクリプトを、Linux ならバイナリ、シェル、Python スクリプトを実行できます。

Batch のすべてのコンピューティング ノードには、次の要素が存在します。

* 標準的な[フォルダー構造](#files-and-directories)と、それに関連付けられた (タスクから参照できる) [環境変数](#environment-settings-for-tasks)。
* **ファイアウォール** 設定。
* [リモート アクセス](#connecting-to-compute-nodes) 。

## <a name="pool"></a>プール
プールは、アプリケーションが実行されるノードのコレクションです。 プールは手動で作成できるほか、実行する操作を指定した場合は Batch サービスによって自動的に作成されます。 アプリケーションのリソース要件を満たすプールを作成して管理することができます。 プールは、そのプールを作成した Batch アカウントのみが使用できます。 1 つの Batch アカウントで複数のプールを持つことができます。

Azure Batch プールは、コア Azure コンピューティング プラットフォームの上に構築されます。 Batch プールによって、大規模な割り当て、アプリケーションのインストール、データの分散、状態の監視、プール内のコンピューティング ノード数の柔軟な調整 ([スケーリング](#scaling-compute-resources)) が可能になります。

プールに追加されたすべてのノードに対し、一意の名前と IP アドレスが割り当てられます。 ノードがプールから削除されると、オペレーティング システムまたはファイルに加えられた変更は失われ、将来使用できるように名前と IP アドレスが解放されます。 ノードをプールから削除すると、その有効期間が終了します。

プールを作成するときに次の属性を指定できます。

- コンピューティング ノードのオペレーティング システムとバージョン
- コンピューティング ノードの種類とターゲット ノード数
- コンピューティング ノードのサイズ
- スケーリング ポリシー
- タスクのスケジューリング ポリシー
- コンピューティング ノードの通信ステータス
- コンピューティング ノードの開始タスク
- アプリケーション パッケージ
- ネットワーク構成

これらの設定それぞれは、次のセクションで詳しく説明しています。

> [!IMPORTANT]
> Batch アカウントには、1 つの Batch アカウントで使用できるコア数に上限を設ける既定のクォータが割り当てられています。 コア数は、コンピューティング ノードの数に対応します。 既定のクォータと、[クォータを増やす](batch-quota-limit.md#increase-a-quota)手順については、「[Azure Batch サービスのクォータと制限](batch-quota-limit.md)」を参照してください。 プールが目標のノード数に到達しない場合は、コア クォータが原因となっている可能性があります。
>


### <a name="compute-node-operating-system-and-version"></a>コンピューティング ノードのオペレーティング システムとバージョン

Batch プールを作成するときは、Azure 仮想マシン構成と、プール内の各コンピューティング ノード上で実行するオペレーティング システムの種類を指定できます。 Batch で使用できる 2 種類の構成は次のとおりです。

- **仮想マシン構成**: プールが Azure 仮想マシンで構成されるように指定します。 これらの VM は、Linux イメージまたは Windows イメージのいずれかから作成できます。 

    仮想マシン構成に基づいてプールを作成する場合は、ノードのサイズと使用するイメージのソースだけでなく、ノードにインストールする**仮想マシン イメージの参照**と Batch **ノード エージェント SKU** も指定する必要があります。 プールに関するこれらのプロパティの指定の詳細については、「 [Azure Batch プールの Linux コンピューティング ノードのプロビジョニング](batch-linux-nodes.md)」を参照してください。 必要に応じて、Marketplace イメージから作成される VM をプールするために 1 つまたは複数の空のデータ ディスクをアタッチするか、VM の作成に使用するカスタム イメージにデータ ディスクを含めることができます。

- **Cloud Services 構成**: プールが Microsoft Azure Cloud Services ノードで構成されるように指定します。 Cloud Services では Windows コンピューティング ノード "*のみ*" が提供されます。

    Cloud Services 構成プールで使用可能なオペレーティング システムは、「 [Azure ゲスト OS リリースと SDK の互換性対応表](../cloud-services/cloud-services-guestos-update-matrix.md)」に一覧が掲載されています。 Cloud Services ノードを含むプールを作成する場合は、ノード サイズとその "*OS ファミリ*" を指定する必要があります。 Cloud Services は、Windows を実行する仮想マシンよりも迅速に Azure にデプロイされます。 Windows コンピューティング ノードのプールが必要な場合、デプロイ時間に関して Cloud Services にパフォーマンスのメリットがあることがわかります。

    * *OS ファミリ* によって、OS と同時にインストールされる .NET のバージョンも決まります。
    * Cloud Services 内の worker ロールと同様、"*OS バージョン*" を指定できます (worker ロールの詳細については、[Cloud Services の概要](../cloud-services/cloud-services-choose-me.md)に関するページを参照してください)。
    * worker ロールの場合と同様に、"*OS バージョン*" には `*` を指定することをお勧めします。これにより、ノードは自動的にアップグレードされ、新たにリリースされたバージョンに対応するための作業が不要になります。 特定の OS バージョンを選択するのは、主にアプリケーションの互換性を確保する必要がある場合です。こうすることで、バージョンの更新を許可する前に旧バージョンとの互換性をテストできます。 検証が終わると、プールの "*OS バージョン*" を更新して、新しい OS イメージをインストールできます。その際、実行中のタスクはすべて中断され、再びキューに置かれます。

プールを作成するときは、VHD のベース イメージの OS に応じて、適切な **nodeAgentSkuId** を選択する必要があります。 [サポートされるノード エージェント SKU をリスト表示する](https://docs.microsoft.com/rest/api/batchservice/list-supported-node-agent-skus)操作を呼び出して、使用可能なノード エージェント SKU ID と OS イメージ参照のマッピングを取得できます。


#### <a name="custom-images-for-virtual-machine-pools"></a>仮想マシン プールのカスタム イメージ

カスタム イメージを使用するには、イメージを一般化して使用できるように準備する必要があります。 Azure VM からカスタムの Linux イメージを準備する方法の詳細については、「[仮想マシンまたは VHD のイメージを作成する方法](../virtual-machines/linux/capture-image.md)」を参照してください。 Azure VM からカスタム Windows イメージを準備する方法については、「[Azure で一般化された VM の管理対象イメージを作成する](../virtual-machines/windows/capture-image-resource.md)」を参照してください。 

詳しい要件と手順については、[カスタム イメージを使用した仮想マシンのプールの作成](batch-custom-images.md)に関するページを参照してください。

#### <a name="container-support-in-virtual-machine-pools"></a>仮想マシンのプールでのコンテナーのサポート

Batch API を使用して仮想マシン構成プールを作成するときに、Docker コンテナーでタスクを実行するためのプールを設定できます。 現在は、Docker コンテナーをサポートするイメージを使ってプールを作成する必要があります。 Azure Marketplace の Windows Server 2016 Datacenter with Containers イメージを使用するか、Docker Community Edition (または Enterprise Edition) と必要なすべてのドライバーを含むカスタム VM イメージを指定する必要があります。 プール設定には、プールの作成時にコンテナー イメージを VM にコピーする[コンテナー構成](/rest/api/batchservice/pool/add#definitions_containerconfiguration)が含まれている必要があります。 これにより、プール上で実行されるタスクが、コンテナー イメージとコンテナー実行オプションを参照できます。

詳細については、「[Azure Batch で Docker コンテナー アプリケーションを実行する](batch-docker-container-workloads.md)」を参照してください。

## <a name="compute-node-type-and-target-number-of-nodes"></a>コンピューティング ノードの種類とターゲット ノード数

プールを作成する場合は、必要なコンピューティング ノードの種類と各ノードのターゲット数を指定できます。 コンピューティング ノードには、次の 2 種類があります。

- **専用のコンピューティング ノード。** 専用のコンピューティング ノードは、ワークロード用に予約されます。 これは優先順位の低いノードより高価ですが、決して割り込まれないことが保証されています。

- **優先順位の低いコンピューティング ノード。** 優先順位の低いノードは、Azure の余剰容量を利用して Batch ワークロードを実行します。 優先順位の低いノードは専用のノードより 1 時間あたりのコストが低く、多くのコンピューティング能力が必要なワークロードを可能にします。 詳細については、「[優先順位の低い VM で Batch を使用する](batch-low-pri-vms.md)」を参照してください。

    優先順位の低いコンピューティング ノードは、Azure の余剰容量が不足している場合、割り込まれる可能性があります。 タスクの実行中にノードが割り込まれた場合、タスクはキューに戻され、コンピューティング ノードが再び使用可能になると再度実行されます。 優先順位の低いノードは、ジョブの完了時間に柔軟性があり、作業が多数のノードにわたって分散されているワークロードには適切なオプションです。 シナリオで優先度の低いノードを使用することを決める前に、割り込みによって失われる処理内容が最小限であり、簡単に再作成できることを確認します。

    
同じプール内で優先順位の低いコンピューティング ノードと専用のコンピューティング ノードの両方を使用できます。 ノードの各種類 &mdash;(優先順位の低いノードと専用のノード)&mdash; には、必要なノード数を指定できる独自のターゲット設定があります。 
    
コンピューティング ノードの数が*ターゲット*と呼ばれるのは、状況によってはプールが必要なノード数に達しないことがあるためです。 たとえば、プールが最初に Batch アカウントの[コア クォータ](batch-quota-limit.md)に達した場合は、ターゲットを実現できないことがあります。 または、プールにノードの最大数を制限する自動スケールの数式を適用している場合は、そのプールがターゲットを実現できないことがあります。

優先順位の低いコンピューティング ノードと専用のコンピューティング ノードの両方の価格情報については、「[Batch Pricing (Batch の価格)](https://azure.microsoft.com/pricing/details/batch/)」を参照してください。

### <a name="size-of-the-compute-nodes"></a>コンピューティング ノードのサイズ

Azure Batch プールを作成する場合に、Azure で使用可能なほぼすべての VM ファミリとサイズを選択することができます。 Azure には、さまざまなワークロードに対応した各種の VM サイズが用意されています。たとえば、特殊な [HPC](../virtual-machines/linux/sizes-hpc.md) または [GPU 対応の](../virtual-machines/linux/sizes-gpu.md) VM サイズなどです。 

詳細については、「[Choose a VM size for compute nodes in an Azure Batch pool (Azure Batch プールのコンピューティング ノード用の VM サイズを選択する)](batch-pool-vm-sizes.md)」を参照してください。

### <a name="scaling-policy"></a>スケーリング ポリシー

動的ワークロードの場合には、プールに[自動スケール式](#scaling-compute-resources)を作成して適用できます。 Batch サービスが、その式を定期的に評価し、プール、ジョブ、タスクに関して指定されている各種パラメーターに基づいてプール内のノード数を調整します。

### <a name="task-scheduling-policy"></a>タスクのスケジューリング ポリシー

プール内の各コンピューティング ノードで並列実行できるタスク数は、 [ノードあたりの最大タスク数](batch-parallel-node-tasks.md) の構成オプションによって上限が決まります。

既定の構成では、1 つのノードで一度に実行されるタスクは 1 つですが、1 つのノードで複数のタスクを同時に実行した方が都合のよい場合もあります。 1 つのノードで複数のタスクを実行することで得られる具体的なメリットについては、[ノードのタスクの同時実行](batch-parallel-node-tasks.md)に関する記事の「[サンプル シナリオ](batch-parallel-node-tasks.md#example-scenario)」を参照してください。

Batch でプール内のすべてのノードにタスクを均等に配分するか、1 つのノードに最大数のタスクを割り当ててから次のノードにタスクを割り当てていくかを明示的に指定することもできます。これは "*フィルの種類*" を指定することによって行います。

### <a name="communication-status-for-compute-nodes"></a>コンピューティング ノードの通信ステータス

ほとんどのシナリオでは、タスクは独立して動作し、相互に通信する必要はありません。 ただし、タスク間の通信が必要なアプリケーションも一部存在します ([MPI のシナリオ](batch-mpi.md)でのアプリケーションなど)。

**ノード間通信**を許可するようにプールを構成し、実行時にプール内のノードが通信できるようにすることができます。 ノード間通信が有効であるとき、Cloud Services の構成のプール内のノードは、1100 を超える番号のポートで互いに通信を行うことができます。仮想マシンの構成のプールでは、いずれかのポートにトラフィックが制限されることはありません。

ノード間通信を有効にすると、クラスター内のノードの配置にも影響が生じるので注意してください。デプロイの制限上、プール内の最大ノード数が制限される場合もあります。 アプリケーションがノード間の通信を必要としない場合、Batch サービスは多くの別のクラスターおよびデータ センターのプールに大量のノードを割り当てることにより、並列処理能力を向上させることができます。

### <a name="start-tasks-for-compute-nodes"></a>コンピューティング ノードの開始タスク

"*開始タスク*" (省略可) は、各ノードがプールに追加されたときにそれぞれのノードで実行されます。また、ノードが再起動されたり再イメージ化されたりするたびに、各ノードで開始タスクが実行されます。 開始タスクは、タスクの実行に使用するコンピューティング ノードを準備する (タスクによってコンピューティング ノードで実行されるアプリケーションをインストールするなど) 場合に特に有効です。

### <a name="application-packages"></a>アプリケーション パッケージ

プール内のコンピューティング ノードにデプロイする[アプリケーション パッケージ](#application-packages)を指定できます。 アプリケーション パッケージにより、タスクによって実行されるアプリケーションのデプロイとバージョン管理がシンプルになります。 プールに指定したアプリケーション パッケージは、そのプールに参加しているすべてのノードにインストールされます。また、ノードが再起動または再イメージ化されるたびにインストールされます。

> [!NOTE]
> アプリケーション パッケージは、2017 年 7 月 5 日より後に作成されたすべての Batch プールでサポートされます。 これらは、プールがクラウド サービス構成を使って作成された場合にのみ、2016 年 3 月 10 日から 2017 年 7 月 5 日までの間に作成された Batch プールでサポートされます。 2016 年 3 月 10 日より前に作成された Batch プールは、アプリケーション パッケージをサポートしていません。 アプリケーション パッケージを使った Batch ノードへのアプリケーションのデプロイについて詳しくは、「[Batch アプリケーション パッケージを使用したコンピューティング ノードへのアプリケーションのデプロイ](batch-application-packages.md)」をご覧ください。
>
>

### <a name="network-configuration"></a>ネットワーク構成

プールのコンピューティング ノードを作成する必要のある Azure [仮想ネットワーク (VNet)](../virtual-network/virtual-networks-overview.md) のサブネットを指定できます。 詳細については、「[プール ネットワーク構成](#pool-network-configuration)」セクションを参照してください。


## <a name="job"></a>ジョブ
ジョブはタスクのコレクションです。 プール内のコンピューティング ノード上で行う計算をそれらのタスクでどのように実行するかを管理します。

* ジョブによって、作業が実行される**プール**を指定します。 ジョブごとに新しくプールを作成できるほか、多数のジョブに対して 1 つのプールを使用することもできます。 ジョブ スケジュールに関連付けられているジョブごとにプールを作成するか、ジョブ スケジュールに関連付けられているすべてのジョブに対してプールを作成してください。
* 必要に応じて **ジョブの優先順位**を指定できます。 現在処理中のジョブよりも優先順位の高いジョブが送信されると、優先順位の高いジョブのタスクが、優先順位の低いジョブのタスクよりも先のキューに挿入されます。 既に実行されている優先順位の低いジョブのタスクが、優先順位の高いタスクに入れ替わることはありません。
* ジョブに対する特定の制限は、ジョブの **制約** を使用して指定できます。

    **最大実時間**を設定できます。この場合、ジョブの実行時間が、指定された最大実時間を超えると、ジョブとそのすべてのタスクが強制的に終了されます。

    失敗したタスクは Batch によって検出され、再試行されます。 **タスク再試行の最大回数**を制約として指定できます。タスクを "*常に*" 再試行するように指定したり、再試行を "*禁止*" したりすることもできます。 タスクの再試行とは、タスクをもう一度実行するためにキューに置くことです。
* クライアント アプリケーションでジョブにタスクを追加するか、[ジョブ マネージャー タスク](#job-manager-task)を指定することができます。 ジョブ マネージャー タスクには、ジョブに必要なタスクを作成するための情報と、プール内のいずれかのコンピューティング ノードで実行されているジョブ マネージャー タスクが含まれます。 ジョブ マネージャー タスクは Batch によってのみ処理されます。ジョブが作成されるとすぐにキューに配置され、失敗すると再開されます。 [ジョブ スケジュール](#scheduled-jobs)によって作成されたジョブには、ジョブ マネージャー タスクが "*必要*" です。ジョブ マネージャー タスク以外では、ジョブがインスタンス化される前にタスクを定義できないためです。
* 既定では、ジョブ内のすべてのタスクが完了しても、ジョブはアクティブな状態のままとなります。 この動作は変更可能です。ジョブ内のすべてのタスクが完了したときにジョブが自動的に終了するように設定できます。 ジョブの **onAllTasksComplete** プロパティ (Batch .NET の [OnAllTasksComplete][net_onalltaskscomplete]) を *terminatejob* に変更することで、ジョブのすべてのタスクが完了状態になったときに、ジョブを自動的に終了することができます。

    Batch サービスは、タスクの " *ない* " ジョブを考慮して、そのすべてのタスクを完了させます。 したがって、このオプションは、 [ジョブ マネージャー タスク](#job-manager-task)で最も一般的に使用されます。 ジョブ マネージャーを使用せずにジョブの自動終了を使用するには、最初に新しいジョブの **onAllTasksComplete** プロパティを *noaction* に設定し、ジョブにタスクを追加し終えた後でのみ *terminatejob* に設定する必要があります。

### <a name="job-priority"></a>ジョブの優先順位
Batch で作成するジョブには、優先順位を割り当てることができます。 Batch サービスは、ジョブの優先順位値を使用して、アカウント内のジョブ スケジューリングの順序を決定します ([スケジュールされたジョブ](#scheduled-jobs)と混同しないでください)。 優先順位として、-1000 ～ 1000 の値を使用します。-1000 は最も低い優先順位を示し、1000 は最も高い優先順位を示します。 ジョブの優先順位を更新するには、[ジョブのプロパティの更新][rest_update_job]操作 (Batch REST) を呼び出すか、[CloudJob.Priority][net_cloudjob_priority] プロパティ (Batch .NET) を変更します。

同じアカウント内で、優先順位の高いジョブは優先順位の低いジョブよりも優先的にスケジュールされます。 あるアカウントの優先順位値が高いジョブが、異なるアカウントの優先順位値が低い別のジョブよりも優先的にスケジュールされることはありません。

複数のプールにわたるジョブ スケジューリングは、独立しています。 異なるプール間では、関連するそのプールでアイドル状態のノードが不足している場合、優先順位の高い方のジョブが最初にスケジュールされるとは限りません。 同じプール内のジョブの場合、優先順位が同じであれば、スケジュールされる可能性は等しくなります。

### <a name="scheduled-jobs"></a>スケジュールされたジョブ
[ジョブ スケジュール][rest_job_schedules]を使用すると、Batch サービス内に、繰り返し発生するジョブを作成することができます。 ジョブ スケジュールは、ジョブをいつ実行するかを指定し、実行されるジョブの仕様を持っています。 スケジュールがいつ有効になって、どのくらいの期間有効であるかというスケジュール期間と、その期間中にどのくらいの頻度でジョブを作成するかを指定することができます。

## <a name="task"></a>タスク
タスクは、ジョブに関連付けられた計算の単位です。 タスクはノードで実行されます。 タスクはノードに割り当てられて実行されるか、ノードが解放されるまでキューに格納されます。 つまりコンピューティング ノード上にある 1 つ以上のプログラム (またはスクリプト) をタスクが実行することによって、必要な作業が遂行されます。

タスクを作成するときに、次の情報を指定できます。

* タスクの**コマンド ライン**。 コンピューティング ノード上のアプリケーションまたはスクリプトを実行するコマンド ラインとして使用されます。

    実際にシェルでコマンド ラインが実行されるわけではないので注意してください。 そのため、`PATH` を含む[環境変数](#environment-settings-for-tasks)の展開など、シェルの機能をネイティブに利用することはできません。 こうした機能を利用するには、コマンド ラインでシェルを呼び出す必要があります。たとえば、次のように Windows ノードでは `cmd.exe` を、Linux では `/bin/sh` を起動します。

    `cmd /c MyTaskApplication.exe %MY_ENV_VAR%`

    `/bin/sh -c MyTaskApplication $MY_ENV_VAR`

    ノードの `PATH` や参照用の環境変数に存在しないアプリケーションまたはスクリプトをタスクで実行する必要がある場合は、タスクのコマンド ラインからシェルを明示的に呼び出してください。
* **リソース ファイル** 。 これらのファイルは、タスクのコマンド ラインが実行される前に、Azure ストレージ アカウントの BLOB ストレージからノードに自動的にコピーされます。 詳細については、「[開始タスク](#start-task)」と「[ファイルとディレクトリ](#files-and-directories)」の各セクションを参照してください。
* アプリケーションで必要な **環境変数** 。 詳細については、「 [タスクの環境設定](#environment-settings-for-tasks) 」セクションを参照してください。
* タスクを実行する際の **制約** 。 この制約には、タスクの実行が許可される最大時間、タスクが失敗した場合に再試行する最大回数、タスクの作業ディレクトリにファイルを保持する最大時間などがあります。
* タスクの実行がスケジュールされているコンピューティング ノードにデプロイする**アプリケーション パッケージ**。 [アプリケーション パッケージ](#application-packages)により、タスクによって実行されるアプリケーションのデプロイとバージョン管理がシンプルになります。 タスクレベルのアプリケーション パッケージは共有プール環境では特に便利です。この環境では、さまざまなジョブが 1 つのプールで実行され、ジョブが完了してもプールは削除されません。 ジョブ内のタスクがプール内のノードよりも少ない場合は、タスクのアプリケーション パッケージによりデータ転送を最小限に抑えることができます。アプリケーションはタスクが実行されるノードにのみデプロイされるためです。
* Docker Hub またはプライベート レジストリ内の**コンテナー イメージ**参照、およびタスクがノード上で実行される Docker コンテナーを作成するための追加設定。 この情報は、プールがコンテナー構成で設定されている場合にのみ指定します。

> [!NOTE]
> タスクの最長有効期間 (ジョブに追加されてから完了するまで) は、7 日間です。 完了したタスクは、無期限に保持されます。最長有効期間内に完了しなかったタスクのデータにはアクセスできません。

Batch サービスには、ノードで計算を実行するために定義するタスクに加えて、次のような特殊なタスクも用意されています。

* [開始タスク](#start-task)
* [ジョブ マネージャー タスク](#job-manager-task)
* [ジョブ準備タスクおよびジョブ解放タスク](#job-preparation-and-release-tasks)
* [マルチインスタンス タスク (MPI)](#multi-instance-tasks)
* [Task dependencies](#task-dependencies)

### <a name="start-task"></a>開始タスク
**開始タスク**をプールに関連付けることによって、ノードの動作環境を準備できます。 たとえば、タスクで実行するアプリケーションのインストールやバックグラウンド プロセスの開始などのアクションを実行できます。 開始タスクは、プール内に保持されている限り、ノードが起動されるたびに実行されます。ノードが最初にプールに追加されたときや、ノードが再起動されたとき、ノードが再イメージ化されたときにも実行されます。

開始タスクの主な利点は、コンピューティング ノードの構成に必要なすべての情報を集約し、タスクの実行に必要なアプリケーションをインストールできることです。 このため、新しいターゲット ノードの数を指定するのと同じくらい簡単にプール内のノードの数を増やすことができます。 新しいノードの構成と、タスクを受け取る準備に必要な情報は、開始タスクから Batch サービスに提供されます。

すべての Azure Batch タスクと同様、実行する**コマンド ライン**のほかに、[Azure Storage][azure_storage] 内の**リソース ファイル**の一覧を指定できます。 Batch サービスは、リソース ファイルを Azure Storage からノードにコピーした後でコマンド ラインを実行します。 プールの開始タスクの場合、このファイル一覧にはタスクのアプリケーションとその依存関係を含めるのが一般的です。

ただし、開始タスクにはコンピューティング ノードで実行されるすべてのタスク用の参照データを含めることもできます。 たとえば、開始タスクのコマンド ラインで `robocopy` 操作を実行し、(リソース ファイルとして指定され、ノードにダウンロードされた) アプリケーション ファイルを開始タスクの[作業ディレクトリ](#files-and-directories)から[共有フォルダー](#files-and-directories)にコピーしたうえで、MSI または `setup.exe` を実行することができます。

一般的には、Batch サービスが開始タスクの完了まで待ってから、タスクを割り当てられる状態になっているノードを判断することが望ましいものの、これは構成可能です。

コンピューティング ノードで開始タスクが失敗した場合、そのノードはエラーを表す状態に更新され、そのノードには一切タスクが割り当てられなくなります。 ストレージからのリソース ファイルのコピーに問題があったり、コマンド ラインで実行されたプロセスからゼロ以外の終了コードが返されたりした場合に、開始タスクは失敗することがあります。

既存のプールの開始タスクを追加または更新するには、そのコンピューティング ノードを再起動して、開始タスクがノードに適用されるようにする必要があります。

>[!NOTE]
> 開始タスクの合計サイズは、リソース ファイルと環境変数を含め、32,768 文字以下であることが必要です。 開始タスクに関して、この要件を確実に満たすためには、次の 2 とおりの方法があります。
>
> 1. アプリケーション パッケージを使って、Batch プール内の各ノードにアプリケーションまたはデータを分散させることができます。 アプリケーション パッケージについて詳しくは、「[Batch アプリケーション パッケージを使用したコンピューティング ノードへのアプリケーションのデプロイ](batch-application-packages.md)」をご覧ください。
> 2. アプリケーション ファイルが含まれた zip アーカイブを手動で作成することができます。 zip アーカイブを Azure Storage に BLOB としてアップロードします。 zip アーカイブを開始タスクのリソース ファイルとして指定します。 開始タスクのコマンド ラインを実行する前に、コマンド ラインから zip アーカイブを解凍します。 
>
>    zip アーカイブの解凍には、任意のアーカイブ ツールを使用してかまいません。 zip アーカイブの解凍に使用するツールは、開始タスクのリソース ファイルとして追加する必要があります。
>
>

### <a name="job-manager-task"></a>ジョブ マネージャー タスク
**ジョブ マネージャー タスク** の通常の用途は、ジョブの実行の制御や監視です。 たとえば、ジョブに対してタスクを作成および送信する場合や、追加で実行するタスクを決める場合、どの時点で作業が完了するかを決める場合などに使用します。 ただし、ジョブ マネージャー タスクはこのようなアクティビティだけに限定されるものではなく、ジョブに必要なすべてのアクションを実行できる、高機能タスクです。 たとえば、ジョブ マネージャー タスクでは、パラメーターとして指定されたファイルをダウンロードし、ファイルの内容を分析して、その内容に基づいた追加のタスクを送信することができます。

ジョブ マネージャー タスクは、他のすべてのタスクの前に開始されます。 また、以下のような特徴があります。

* ジョブの作成時に Batch サービスによって自動的にタスクとして送信されます。
* ジョブ内の他のタスクより先に実行されるようにスケジュールされます。
* ジョブ マネージャー タスクに関連付けられたノードは、プールが縮小される際、プールから最後に削除されます。
* ジョブ マネージャー タスクの終了を、ジョブ内のすべてのタスクの終了に関連付けることができます。
* ジョブ マネージャー タスクを再起動する必要がある場合は、最も高い優先順位が割り当てられます。 アイドル状態のノードを使用できない場合、Batch サービスはジョブ マネージャー タスクを実行する余地を確保するために、プール内のいずれかの実行中のタスクを終了する場合があります。
* あるジョブ内のジョブ マネージャー タスクに、他のジョブのタスクに対して高い優先順位が割り当てられることはありません。 ジョブ間では、ジョブ レベルの優先順位のみが適用されます。

### <a name="job-preparation-and-release-tasks"></a>ジョブ準備タスクおよびジョブ解放タスク
Batch には、ジョブ実行前の設定用にジョブ準備タスク、 ジョブ実行後のメンテナンスやクリーンアップ用にジョブ解放タスクが用意されています。

* **ジョブ準備タスク**: ジョブ準備タスクは、タスクの実行がスケジュールされているすべてのコンピューティング ノードで、他のジョブ タスクの実行前に実行されます。 たとえば、ジョブごとに異なるものの、すべてのタスクによって共有されるデータをコピーするために、ジョブ準備タスクを使用することができます。
* **ジョブ解放タスク**: ジョブが完了すると、少なくとも 1 つのタスクを実行したプールの各ノードでジョブ解放タスクが実行されます。 たとえば、ジョブ準備タスクによってコピーされたデータを削除したり、診断ログ データを圧縮してアップロードしたりするために、ジョブ解放タスクを使用することができます。

ジョブ準備タスクとジョブ解放タスクのどちらでも、タスクの呼び出し時に実行するコマンド ラインを指定できます。 これらのタスクは、ファイルのダウンロード、管理者特権での実行、カスタム環境変数、最大実行期間、再試行回数、ファイルのリテンション期間などの機能を備えています。

ジョブ準備タスクとジョブ解放タスクの詳細については、「 [Azure Batch コンピューティング ノードでのジョブ準備タスクとジョブ完了タスクの実行](batch-job-prep-release.md)」を参照してください。

### <a name="multi-instance-task"></a>マルチインスタンス タスク
[マルチインスタンス タスク](batch-mpi.md) は、複数のコンピューティング ノードで同時に実行するように構成されたタスクです。 複数のコンピューティング ノードをまとめて 1 つのワークロードの処理に割り当てる Message Passing Interface (MPI) など、ハイ パフォーマンス コンピューティングが要求されるシナリオには、マルチインスタンス タスクを使って対応することができます。

Batch .NET ライブラリを使用して MPI ジョブを Batch で実行する方法の詳細な説明については、「 [Azure Batch でのマルチインスタンス タスクを使用した Message Passing Interface (MPI) アプリケーションの実行](batch-mpi.md)」を参照してください。

### <a name="task-dependencies"></a>Task dependencies
[タスクの依存関係](batch-task-dependencies.md)は、名前が示すとおり、あるタスクを実行するには、事前にその他のタスクが完了している必要があることを指定できる機能です。 この機能は、"下流" のタスクが "上流" のタスクの出力を使用するような状況や、下流のタスクで必要になる初期化を上流のタスクで実行するような状況に対応できます。 この機能を使用するには、まず Batch ジョブでタスクの依存関係を有効にする必要があります。 その後、別のタスク (または他の複数のタスク) に依存するタスクごとに、どのタスクに依存するかを指定します。

タスクの依存関係がある場合、シナリオを次のように構成できます。

* *taskB* が *taskA* に依存する (*taskB* の実行は *taskA* が完了するまで開始されない)。
* *taskC* は *taskA* と *taskB* の両方に依存。
* *taskD* が、実行されるまで特定の範囲のタスク (タスク *1* ～ *10* など) に依存する。

この機能の詳細については、「[Azure Batch におけるタスクの依存関係](batch-task-dependencies.md)」と、[azure-batch-samples][github_samples] GitHub リポジトリの [TaskDependencies][github_sample_taskdeps] コード サンプルを参照してください。

## <a name="environment-settings-for-tasks"></a>タスクの環境設定
Batch サービスによって実行されるすべてのタスクは、コンピューティング ノード上に設定されている環境変数を利用することができます。 これには、Batch サービスによって定義された ([サービス定義][msdn_env_vars]の) 環境変数のほか、ユーザーがタスクに対して定義するカスタム環境変数が含まれます。 これらの環境変数は、タスクによって実行されるアプリケーションやスクリプトから実行中に利用することができます。

カスタム環境変数は、タスクまたはジョブの *環境設定* プロパティを設定することで、タスク レベルまたはジョブ レベルで設定できます。 その例については、[ジョブへのタスクの追加][rest_add_task]操作 (Batch REST API) に関するページ、または [CloudTask.EnvironmentSettings][net_cloudtask_env] プロパティと [CloudJob.CommonEnvironmentSettings][net_job_env] プロパティ (Batch .NET) に関するページを参照してください。

クライアント アプリケーションまたはサービスからタスクのサービス定義またはカスタムの環境変数を取得するには、[タスクに関する情報の取得][rest_get_task_info]操作 (Batch REST) を使用するか、[CloudTask.EnvironmentSettings][net_cloudtask_env] プロパティ (Batch .NET) にアクセスします。 コンピューティング ノードで実行されるプロセスは、たとえば `%VARIABLE_NAME%` (Windows) や `$VARIABLE_NAME` (Linux) という一般的な構文を使用して、ノード上のこうしたさまざまな環境変数を利用することができます。

サービス定義の環境変数をすべて網羅した一覧を、[コンピューティング ノードの環境変数][msdn_env_vars]に関するページで確認できます。

## <a name="files-and-directories"></a>ファイルとディレクトリ
各タスクには "*作業ディレクトリ*" があります。そこに、タスクがファルやディレクトリを作成します。 この作業ディレクトリは、タスクによって実行されるプログラム、処理されるデータ、実行される処理の出力を格納するために使用できます。 タスクのすべてのファイルとディレクトリは、タスクのユーザーが所有者になります。

Batch サービスは、ノード上のファイル システムの一部を " *ルート ディレクトリ*" として公開します。 このルート ディレクトリには、タスクから `AZ_BATCH_NODE_ROOT_DIR` 環境変数を参照することでアクセスできます。 環境変数の使用に関する詳細については、「 [タスクの環境設定](#environment-settings-for-tasks)」を参照してください。

ルート ディレクトリには、次のディレクトリ構造が含まれています。

![コンピューティング ノードのディレクトリ構造][1]

* **shared**: ノードで実行される " *すべて* " のタスクに、このディレクトリへの読み取り/書き込みアクセス権が与えられます。 ノード上で実行されるすべてのタスクは、このディレクトリのファイルを作成、読み取り、更新、削除することができます。 このディレクトリには、タスクから `AZ_BATCH_NODE_SHARED_DIR` 環境変数を参照することでアクセスできます。
* **startup**: この場所は、開始タスクの作業ディレクトリとして使用されます。 開始タスクによってノードにダウンロードされるすべてのファイルは、ここに格納されます。 開始タスクは、このディレクトリの下で、ファイルを作成、読み取り、更新、削除できます。 このディレクトリには、タスクから `AZ_BATCH_NODE_STARTUP_DIR` 環境変数を参照することでアクセスできます。
* **タスク**: ノード上で実行されるタスクごとに、ディレクトリが作成されます。 このディレクトリには、 `AZ_BATCH_TASK_DIR` 環境変数を参照することでアクセスできます。

    各タスク ディレクトリ内に、Batch サービスによって作業ディレクトリ (`wd`) が作成されます。その一意のパスは、`AZ_BATCH_TASK_WORKING_DIR` 環境変数によって指定されます。 このディレクトリは、タスクに読み取り/書き込みアクセスを提供します。 タスクは、このディレクトリの下で、ファイルを作成、読み取り、更新、および削除できます。 このディレクトリは、タスクに対して指定された *RetentionTime* 制約に基づいて保持されます。

    `stdout.txt` および `stderr.txt`: これらのファイルは、タスクの実行中にタスク フォルダーに書き込まれます。

> [!IMPORTANT]
> ノードをプールから削除すると、ノードに格納されている " *すべて* " のファイルが削除されます。
>
>

## <a name="application-packages"></a>アプリケーション パッケージ
[アプリケーション パッケージ](batch-application-packages.md) 機能は、プール内のコンピューティング ノードにアプリケーションを簡単にデプロイして管理できる機能です。 バイナリやサポート ファイルも含め、タスクによって実行される複数のバージョンのアプリケーションをアップロードして管理できます。 また、アップロードしたアプリケーションのうち 1 つ以上をプール内のコンピューティング ノードに自動的にデプロイできます。

アプリケーション パッケージはプール レベルおよびタスク レベルで指定できます。 プールのアプリケーション パッケージを指定した場合、アプリケーションはプール内のすべてのノードにデプロイされます。 タスクのアプリケーション パッケージを指定した場合、タスクのコマンド ラインが実行される直前に、ジョブのタスクのうち、少なくとも 1 つの実行がスケジュールされているノードにのみ、アプリケーションがデプロイされます。

Batch は Azure Storage との細かいやり取りを処理し、アプリケーション パッケージを格納してコンピューティング ノードにデプロイするため、コードと管理オーバーヘッドの両方を簡略化できます。

アプリケーション パッケージの機能について詳しくは、「[Batch アプリケーション パッケージを使用したコンピューティング ノードへのアプリケーションのデプロイ](batch-application-packages.md)」をご覧ください。

> [!NOTE]
> プールのアプリケーション パッケージを " *既存* " のプールに追加した場合は、そのコンピューティング ノードを再起動して、アプリケーション パッケージをノードにデプロイする必要があります。
>
>

## <a name="pool-and-compute-node-lifetime"></a>プールとコンピューティング ノードの有効期間
Azure Batch ソリューションを設計するときは、いつ、どのようにプールを作成するかと、それらのプール内のコンピューティング ノードをどのくらいの期間利用できるようにしておくかを考慮する必要があります。

1 つの方法として、送信する各ジョブについてプールを作成し、対応するタスクが実行を終えた直後にそのプールを削除することができます。 必要なときにのみノードが割り当てられ、ノードがアイドル状態になるとすぐにシャットダウンされるので、使用効率はきわめて高くなります。 ジョブはノードが割り当てられるまで待機する必要がありますが、ノードが個別に使用可能になって割り当てられ、開始タスクが完了するとすぐに、タスクの実行がスケジュール設定されることに注意してください。 つまり、プール内のすべてのノードが使用可能になるまで Batch がタスクをノードに割り当てずに待機するようなことは "*ありません*"。 そのため、使用可能なすべてのノードで使用率が最大になります。

もう一方の極端な例としては、ジョブをすぐに開始することが最優先事項であるような場合、プールを事前に作成し、ジョブが送信される前にノードを使用可能にしておくという方法があります。 この場合はタスクをすぐに開始できますが、ノードはタスクが割り当てられるまでアイドル状態で待機する可能性があります。

変動の大きい継続的な負荷に対応するために、通常はこれらを組み合わせた方法が採用されます。 この場合は複数のジョブの送信先とするプールを用意することができますが、ジョブの負荷に応じてノードの数を増減することもできます (以下のセクションの「[コンピューティング リソースのスケーリング](#scaling-compute-resources)」を参照)。 この方法では、現在の負荷に応じて事後的に対応できます。また、負荷を予測できる場合は事前に対応することもできます。

## <a name="virtual-network-vnet-and-firewall-configuration"></a>仮想ネットワーク (VNet) とファイアウォールの構成 

コンピューティング ノードのプールを Batch でプロビジョニングする際に、プールを Azure [仮想ネットワーク (VNet)](../virtual-network/virtual-networks-overview.md) のサブネットに関連付けることができます。 Azure VNet を使用するには、Batch クライアント API で Azure Active Directory (AD) 認証を使用する必要があります。 Azure AD の Azure Batch のサポートについては、「[Batch サービスの認証に Active Directory を使用する](batch-aad-auth.md)」に記載されています。  

### <a name="vnet-requirements"></a>VNet に関する要件
[!INCLUDE [batch-virtual-network-ports](../../includes/batch-virtual-network-ports.md)]

VNet で Batch プールを設定する方法の詳細については、[仮想ネットワークでの仮想マシンのプールの作成](batch-virtual-network.md)に関するページを参照してください。

## <a name="scaling-compute-resources"></a>コンピューティング リソースのスケーリング
[自動スケール](batch-automatic-scaling.md)を使用すると、現在のコンピューティング環境のワークロードとリソース使用量に応じて、Batch サービスでプール内のコンピューティング ノードの数を動的に調整できます。 これにより、必要なリソースのみを使用し、不要なリソースを解放することで、アプリケーションの全体的な実行コストを削減することができます。

自動スケールを有効にするには、 [自動スケール式](batch-automatic-scaling.md#automatic-scaling-formulas) を作成してプールに関連付けます。 Batch サービスは、この式を使用して、次のスケール間隔 (構成可能な間隔) におけるプール内のノードの目標数を決定します。 プールの自動スケール設定は、プールの作成時に指定できるほか、後からプールに対してスケーリングを有効にすることもできます。 スケーリングが有効にされたプールのスケーリング設定を更新することもできます。

たとえばジョブによっては、膨大な数のタスクを実行対象として送信することが要求されることも考えられます。 この場合、現在キューに格納されているタスクの数とジョブ内のタスクの完了率に基づいてプール内のノード数を調整するスケール式をプールに割り当てることができます。 Batch サービスは、定期的に式を評価し、ワークロードと他の式の設定に基づいてプールのサイズを変更します。 このサービスでは、キュー内のタスクの数が多くなるとそれに応じて必要なノードが追加され、キュー内のタスクや実行中のタスクがなくなるとノードが削除されます。

スケーリング式には、次のメトリックを使用できます。

* **時間メトリック** : 指定した時間数内で 5 分おきに収集された統計情報に基づきます。
* **リソース メトリック** : CPU 使用量、帯域幅使用量、メモリ使用量、およびノードの数に基づきます。
* **タスク メトリック**: "*アクティブ*" (キューに登録済み)、"*実行中*"、"*完了*" などのタスクの状態に基づきます。

プール内のコンピューティング ノードの数が自動スケールによって縮小される場合、その縮小操作のタイミングで実行されているタスクの扱いを考慮に入れる必要があります。 その点に対応するために、Batch には " *ノードの割り当て解除オプション* " が用意されていて、それを式に含めることができます。 たとえば、実行中のタスクを即座に停止したうえで再度キューに登録して別のノードで実行するか、完了するまで待ってノードをプールから削除するかを指定できます。

アプリケーションの自動的なスケーリングの詳細については、「 [Azure Batch プール内のコンピューティング ノードの自動スケール](batch-automatic-scaling.md)」を参照してください。

> [!TIP]
> コンピューティング リソースの使用率を最大にするには、ジョブ完了時のノードの目標個数を 0 に設定し、実行中のタスクは完了するまで実行するようにします。
>
>

## <a name="security-with-certificates"></a>証明書によるセキュリティ
証明書を使用する必要があるのは、通常、[Azure Storage アカウント][azure_storage]のキーなど、タスクの機密情報を暗号化または復号化するときです。 このようなときは、ノードに証明書をインストールすることで対応できます。 暗号化された機密情報は、コマンド ライン パラメーターを通じてタスクに渡されるか、タスク リソースの 1 つに埋め込まれます。インストールされた証明書を使用して、機密情報を復号化できます。

[証明書の追加][rest_add_cert]操作 (Batch REST) または [CertificateOperations.CreateCertificate][net_create_cert] メソッド (Batch .NET) を使用して、Batch アカウントに証明書を追加できます。 次に、新規または既存のプールに証明書を関連付けることができます。 証明書がプールに関連付けられると、Batch サービスは、プール内の各ノードに証明書をインストールします。 Batch サービスは、ノードの起動時に、いずれかのタスク (開始タスク、ジョブ マネージャー タスクも含まれます) を起動する前に、適切な証明書をインストールします。

証明書を " *既存* " のプールに追加した場合は、そのコンピューティング ノードを再起動して、証明書をノードに適用する必要があります。

## <a name="error-handling"></a>エラー処理
Batch ソリューション内でタスク エラーとアプリケーション エラーを処理することが必要になる場合があります。

### <a name="task-failure-handling"></a>タスクのエラー処理
タスク エラーは、以下のカテゴリに分類されます。

* **前処理エラー**

    タスクを開始できなかった場合、そのタスクには前処理エラーが設定されます。  

    前処理エラーの原因には、タスクのリソース ファイルが移動された、Storage アカウントが利用できなくなった、ノードへのファイルのコピーに支障をきたす別の問題が発生した、などがあります。

* **ファイル アップロード エラー**

    タスクに対して指定されたファイルのアップロードがなんらかの理由で失敗すると、タスクにファイル アップロード エラーが設定されます。

    ファイル アップロード エラーの原因には、Azure Storage にアクセスするために指定された SAS が無効であるか書き込み権限がない、ストレージ アカウントが利用できなくなった、ノードからのファイルのコピーに支障をきたす別の問題が発生した、などがあります。    

* **アプリケーション エラー**

    タスクのコマンド ラインで指定されたプロセスも失敗することがあります。 タスクで実行されたプロセスによってゼロ以外の終了コードが返された場合、プロセスが失敗したと見なされます (次のセクションの「 *タスクの終了コード* 」を参照)。

    アプリケーション エラーについては、指定された回数まで自動的にタスクを再試行するように Batch を構成することができます。

* **制約エラー**

    ジョブまたはタスクの最大実行期間を指定する制約である *maxWallClockTime*を設定することができます。 これは、処理に失敗したタスクを終了させる場合に便利です。

    最大実行時間を超過したタスクは "*完了*" としてマークされますが、終了コードは `0xC000013A` に設定され、*schedulingError* フィールドは `{ category:"ServerError", code="TaskEnded"}` としてマークされます。

### <a name="debugging-application-failures"></a>アプリケーション エラーのデバッグ
* `stderr` と `stdout`

    アプリケーションの実行中に、問題のトラブルシューティングに利用できる診断情報が生成される場合があります。 前述の「[ファイルとディレクトリ](#files-and-directories)」セクションで説明したように、Batch サービスは、コンピューティング ノードのタスク ディレクトリにある `stdout.txt` ファイルと `stderr.txt` ファイルに標準出力と標準エラー出力を書き込みます。 これらのファイルは Azure Portal またはいずれかの Batch SDK を使用してダウンロードすることができます。 たとえば、Batch .NET ライブラリの [ComputeNode.GetNodeFile][net_getfile_node] や [CloudTask.GetNodeFile][net_getfile_task] でこれらのファイルを取得して、トラブルシューティングに利用できます。

* **タスクの終了コード**

    前述したように、タスクによって実行されたプロセスからゼロ以外の終了コードが返された場合、そのタスクには、失敗したことを示すマークが Batch サービスによって設定されます。 タスクでプロセスが実行されると、Batch によって、そのタスクの終了コード プロパティに "*プロセスのリターン コード*" が設定されます。 タスクの終了コードを決めるのは Batch サービスでは**ない**ことに注意してください。 タスクの終了コードは、プロセス自体またはそのプロセスを実行したオペレーティング システムによって決定されます。

### <a name="accounting-for-task-failures-or-interruptions"></a>タスクのエラーや中断の理由
タスクは、エラーが発生したり中断されたりする場合があります。 タスク アプリケーション自体でエラーが発生したり、タスクが実行されているノードが再起動したりすることがあります。また、プールの割り当て解除ポリシーがタスクの完了を待たずに直ちにノードを削除するように設定されている場合は、サイズ変更操作中にノードがプールから削除されることもあります。 どのようなケースでも、Batch によってタスクを自動的にキューに戻し、別のノードで実行することができます。

断続的に発生する問題によって、タスクが応答を停止したり、実行に長い時間がかかるようになる場合もあります。 このような場合は、タスクに最大実行間隔を設定することができます。 最大実効間隔を超過すると、Batch サービスによってタスク アプリケーションが中断されます。

### <a name="connecting-to-compute-nodes"></a>コンピューティング ノードへの接続
リモートからコンピューティング ノードにサインインすることによって、さらに踏み込んだデバッグやトラブルシューティングを実行できます。 Azure Portal を使用して、Windows ノードのリモート デスクトップ プロトコル (RDP) ファイルをダウンロードしたり、Linux ノードの Secure Shell (SSH) 接続情報を取得したりすることができます。 このような操作は、Batch API ([Batch .NET][net_rdpfile]、[Batch Python](batch-linux-nodes.md#connect-to-linux-nodes-using-ssh) など) で実行することもできます。

> [!IMPORTANT]
> RDP や SSH を通じてノードに接続するには、まず、ノード上にユーザーを作成する必要があります。 Azure Portal から Batch REST API を使用して[ユーザー アカウントをノードに追加][rest_create_user]し、Batch .NET の [ComputeNode.CreateComputeNodeUser][net_create_user] メソッドを呼び出すか、Batch Python モジュールの [add_user][py_add_user] メソッドを呼び出してください。
>
>

計算ノードへの RDP アクセスまたは SSH アクセスを制限または無効にする必要がある場合は、「[Configure or disable remote access to compute nodes in an Azure Batch pool (Azure Batch プールの計算ノードへのリモート アクセスを構成または無効にする)](pool-endpoint-configuration.md)」を参照してください。

### <a name="troubleshooting-problematic-compute-nodes"></a>問題のあるコンピューティング ノードのトラブルシューティング
一部のタスクが失敗する場合は、Batch クライアント アプリケーションまたはサービスで、失敗したタスクのメタデータを調べて、正常に動作していないノードを特定できます。 プール内のノードにはそれぞれ一意の ID があり、タスクが実行されるノードはタスクのメタデータに含まれています。 問題のあるノードが特定できたら、そのノードで以下に示すいくつかの対策を実行します。

* **ノードを再起動する** ([REST][rest_reboot] | [.NET][net_reboot])

    ノードを再起動すると、途中で停止したプロセスやクラッシュしたプロセスなどの潜在的な問題が解決することがあります。 プールで開始タスクを使用している場合や、ジョブでジョブ準備タスクを使用している場合、それらのタスクはノードの再起動時に実行されます。
* **ノードを再イメージ化する** ([REST][rest_reimage] | [.NET][net_reimage])

    この操作では、ノード上のオペレーティング システムが再インストールされます。 ノードの再起動と同様、開始タスクとジョブ準備タスクはノードの再イメージ化後に再実行されます。
* **プールからノードを削除する** ([REST][rest_remove] | [.NET][net_remove])

    場合によっては、プールからノードを完全に削除する必要があります。
* **ノードでタスク スケジュールを無効にする** ([REST][rest_offline] | [.NET][net_offline])

    この操作では、ノードが実質的にオフラインになります。そのため、これ以上タスクが割り当てられなくなりますが、ノードをプール内で稼働したままにできます。 これにより、失敗したタスクのデータが失われず、これ以上ノードでタスクが失敗することもなくなり、エラーの原因を詳しく調査できます。 たとえば、ノードでタスク スケジュールを無効にした後、[リモートでサインイン](#connecting-to-compute-nodes)して、ノードのイベント ログを確認したり、他のトラブルシューティングを実行したりできます。 調査が完了したら、タスク スケジュールを有効にする ([REST][rest_online] | [.NET][net_online]) ことで、ノードをオンラインに戻すことができます。また、前述した他のいずれかのアクションを実行することもできます。

> [!IMPORTANT]
> このセクションで説明した各アクション (再起動、再イメージ化、削除、タスク スケジュールの無効化) では、アクションを実行するときに、ノードで現在実行中のタスクの処理方法を指定できます。 たとえば、Batch .NET クライアント ライブラリを使用してノードでタスク スケジュールを無効にする際に、[DisableComputeNodeSchedulingOption][net_offline_option] 列挙値を指定して、実行中のタスクを終了するか (**Terminate**)、他のノードでスケジュールするためにキューに再登録するか (**Requeue**)、実行中のタスクが完了してからアクションを実行するか (**TaskCompletion**) を指定できます。
>
>

## <a name="next-steps"></a>次の手順
* Batch ソリューションの構築に使用できる [Batch API とツール](batch-apis-tools.md)について学習します。
* [Batch .NET クライアント ライブラリ](quick-run-dotnet.md)または [Python](quick-run-python.md) を使用した Batch 対応アプリケーションの開発に関する基本事項を確認してください。 これらのクイック スタートでは、Batch サービスを使用して複数のコンピューティング ノードでワークロードを実行するサンプル アプリケーションの開発手順を説明しています。また、Azure Storage を使用してワークロード ファイルのステージングと取得を行う方法についても取り上げています。
* Batch ソリューションを開発するときに使用する [Batch Explorer][batch_labs] をダウンロードしてインストールします。 Batch Explorer は、Azure Batch アプリケーションの作成、デバッグ、および監視に役立ちます。 
* [Stack Overflow](http://stackoverflow.com/questions/tagged/azure-batch)、[Batch Community リポジトリ](https://github.com/Azure/Batch)、MSDN の [Azure Batch フォーラム][batch_forum]などのコミュニティ リソースを参照してください。 

[1]: ./media/batch-api-basics/node-folder-structure.png

[azure_storage]: https://azure.microsoft.com/services/storage/
[batch_forum]: https://social.msdn.microsoft.com/Forums/en-US/home?forum=azurebatch
[cloud_service_sizes]: ../cloud-services/cloud-services-sizes-specs.md
[msmpi]: https://msdn.microsoft.com/library/bb524831.aspx
[github_samples]: https://github.com/Azure/azure-batch-samples
[github_sample_taskdeps]:  https://github.com/Azure/azure-batch-samples/tree/master/CSharp/ArticleProjects/TaskDependencies
[batch_labs]: https://azure.github.io/BatchExplorer/
[batch_net_api]: https://msdn.microsoft.com/library/azure/mt348682.aspx
[msdn_env_vars]: https://msdn.microsoft.com/library/azure/mt743623.aspx
[net_cloudjob_jobmanagertask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.jobmanagertask.aspx
[net_cloudjob_priority]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.priority.aspx
[net_cloudpool_starttask]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudpool.starttask.aspx
[net_cloudtask_env]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.environmentsettings.aspx
[net_create_cert]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.certificateoperations.createcertificate.aspx
[net_create_user]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.createcomputenodeuser.aspx
[net_getfile_node]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.getnodefile.aspx
[net_getfile_task]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudtask.getnodefile.aspx
[net_job_env]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.commonenvironmentsettings.aspx
[net_multiinstancesettings]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.multiinstancesettings.aspx
[net_onalltaskscomplete]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.cloudjob.onalltaskscomplete.aspx
[net_rdp]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.getrdpfile.aspx
[net_reboot]: https://msdn.microsoft.com/library/azure/mt631495.aspx
[net_reimage]: https://msdn.microsoft.com/library/azure/mt631496.aspx
[net_remove]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.pooloperations.removefrompoolasync.aspx
[net_offline]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.disableschedulingasync.aspx
[net_online]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.computenode.enableschedulingasync.aspx
[net_offline_option]: https://msdn.microsoft.com/library/azure/microsoft.azure.batch.common.disablecomputenodeschedulingoption.aspx
[net_rdpfile]: https://msdn.microsoft.com/library/azure/Mt272127.aspx
[vnet]: https://msdn.microsoft.com/library/azure/dn820174.aspx#bk_netconf

[py_add_user]: https://docs.microsoft.com/en-us/python/azure/?view=azure-python

[batch_rest_api]: https://msdn.microsoft.com/library/azure/Dn820158.aspx
[rest_add_job]: https://msdn.microsoft.com/library/azure/mt282178.aspx
[rest_add_pool]: https://msdn.microsoft.com/library/azure/dn820174.aspx
[rest_add_cert]: https://msdn.microsoft.com/library/azure/dn820169.aspx
[rest_add_task]: https://msdn.microsoft.com/library/azure/dn820105.aspx
[rest_create_user]: https://msdn.microsoft.com/library/azure/dn820137.aspx
[rest_get_task_info]: https://msdn.microsoft.com/library/azure/dn820133.aspx
[rest_job_schedules]: https://msdn.microsoft.com/library/azure/mt282179.aspx
[rest_multiinstance]: https://msdn.microsoft.com/library/azure/mt637905.aspx
[rest_multiinstancesettings]: https://msdn.microsoft.com/library/azure/dn820105.aspx#multiInstanceSettings
[rest_update_job]: https://msdn.microsoft.com/library/azure/dn820162.aspx
[rest_rdp]: https://msdn.microsoft.com/library/azure/dn820120.aspx
[rest_reboot]: https://msdn.microsoft.com/library/azure/dn820171.aspx
[rest_reimage]: https://msdn.microsoft.com/library/azure/dn820157.aspx
[rest_remove]: https://msdn.microsoft.com/library/azure/dn820194.aspx
[rest_offline]: https://msdn.microsoft.com/library/azure/mt637904.aspx
[rest_online]: https://msdn.microsoft.com/library/azure/mt637907.aspx

[vm_marketplace]: https://azure.microsoft.com/marketplace/virtual-machines/
