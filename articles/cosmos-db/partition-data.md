---
title: Azure Cosmos DB でのパーティション分割と水平スケーリング | Microsoft Docs
description: Azure Cosmos DB でのパーティション分割のしくみ、パーティション分割とパーティション キーを構成する方法、アプリケーションに適したパーティション キーを選択する方法について説明します。
services: cosmos-db
author: aliuy
manager: kfile
ms.service: cosmos-db
ms.devlang: na
ms.topic: conceptual
ms.date: 07/26/2018
ms.author: andrl
ms.custom: H1Hack27Feb2017
ms.openlocfilehash: c9c1379cd457dcba37246985058b01e85633f968
ms.sourcegitcommit: 387d7edd387a478db181ca639db8a8e43d0d75f7
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/10/2018
ms.locfileid: "40038476"
---
# <a name="partition-and-scale-in-azure-cosmos-db"></a>Azure Cosmos DB でのパーティション分割とスケーリング

[Azure Cosmos DB](https://azure.microsoft.com/services/cosmos-db/) は、世界規模で分散配置されるマルチモデルのデータベース サービスであり、高速で予測可能なパフォーマンスを実現するうえで役立つよう設計されています。 お使いのアプリケーションに合わせて、シームレスにスケーリングされます。 この記事では、Azure Cosmos DB におけるあらゆるデータ モデルのパーティション分割のしくみについて概説します。 また、Azure Cosmos DB コンテナーを構成して効果的にアプリケーションをスケーリングする方法についても説明します。

このビデオでは、パーティション分割とパーティション キーについて説明します。

> [!VIDEO https://www.youtube.com/embed/SS6WrQ-HJ30]
> 

## <a name="partitioning-in-azure-cosmos-db"></a>Azure Cosmos DB でのパーティション分割
Azure Cosmos DB は、コレクション (ドキュメント用)、グラフ、またはテーブルと呼ばれるデータを格納するためのコンテナーを提供します。 コンテナーは論理リソースであり、1 つ以上の物理パーティションまたはサーバーにまたがることができます。 パーティションの数は、1 つのコンテナーまたは一連のコンテナーに対してプロビジョニングされたストレージ サイズとスループットに基づいて、Azure Cosmos DB によって決定されます。 


### <a name="physical-partition"></a>物理パーティション

"*物理*" パーティションは、固定容量の SSD を基盤とする予約済みストレージと、可変容量のコンピューティング リソース (CPU およびメモリ) の組み合わせです。 各物理パーティションは、高可用性のためにレプリケートされます。 各コンテナー セットは、1 つまたは複数の物理パーティションを共有する場合があります。 物理パーティションの管理は Azure Cosmos DB で完全に行われるため、複雑なコードを記述してパーティションを管理する必要がありません。 Azure Cosmos DB のコンテナーは、ストレージとスループットに関して、事実上制限がありません。 物理パーティションは Azure Cosmos DB の内的概念で、一時的なものです。 Azure Cosmos DB はワークロードに基づいて物理パーティションの数を自動的にスケールします。 そのため、物理パーティションの数に基づいてデータベース設計を相関させる必要はなく、代わりに、論理パーティションを決定する適切なパーティション キーを的確に選択する必要があります。 

### <a name="logical-partition"></a>論理パーティション

*論理*パーティションは、1 つのパーティション キー値に関連付けられているすべてのデータを格納する物理パーティション内のパーティションです。 複数の論理パーティションは、同一の物理パーティションにまとめることができます。 次の図では、1 つのコンテナーに 3 つの論理パーティションが含まれています。 各論理パーティションは、それぞれ 1 つのパーティション キー、LAX、AMS、MEL のデータを格納します。 LAX、AMS、および MEL の各論理パーティションは、10 GB の論理パーティションの上限を超えることはできません。 

![リソースのパーティション分割](./media/introduction/azure-cosmos-db-partitioning.png) 

コンテナーが[パーティション分割の前提条件](#prerequisites)を満たしている場合、パーティション分割は、アプリケーションに対して完全に透過的です。 Azure Cosmos DB では、物理および論理パーティションにデータを配布して、適切なパーティションに対するクエリ要求をルーティングする処理を行います。 

## <a name="how-does-partitioning-work"></a>パーティション分割のしくみ

各ドキュメントは、一意に特定するための*パーティション キー*と*行キー*を保持する必要があります。 パーティション キーは、データの論理上のパーティションとして機能し、複数の物理パーティションに対してデータを分散配置する際の自然境界を Azure Cosmos DB に提供します。 **1 つの論理パーティションのデータは、1 つの物理パーティション内に存在する必要があり、物理パーティションの管理は Azure Cosmos DB によって行われます**。 

以下、Azure Cosmos DB におけるパーティション分割のしくみを簡単に説明します。

* **T** RU/秒 (1 秒あたりの要求数) のスループットで、一連の Azure Cosmos DB コンテナーをプロビジョニングします。  
* バックグラウンドで、Azure Cosmos DB が、1 秒あたり **T** 要求を提供するために必要な物理パーティションをプロビジョニングします。 物理パーティションあたりの最大スループット **t** を **T** が超えている場合、Azure Cosmos DB は、**N = T/t** 個の物理パーティションをプロビジョニングします。 パーティションあたりの最大スループットの値 (t) は、Azure Cosmos DB によって構成されます。この値は、プロビジョニング済みスループットの合計と使用されたハードウェア構成に基づいて割り当てられます。  
* Azure Cosmos DB が **N** 個の物理パーティションに対し、パーティション キー ハッシュのキー空間を均等に割り当てます。 これにより、各物理パーティションがホストする論理パーティションの数は、**1/N** * パーティション キー値の数になります。  
* 物理パーティション **p** がその容量の上限に達すると、Azure Cosmos DB は **p** を 2 つの新しい物理パーティション (**p1** と **p2**) にシームレスに分割し、 おおよそ半分のキーに対応する値を、新しい各物理パーティションに分散配置します。 この分割操作は、アプリケーションからはまったく見えません。 物理パーティションがその容量の上限に達しても、物理パーティションのすべてのデータが同じ論理パーティション キーに属している場合は、分割操作は発生しません。 これは、1 つの論理パーティション キーのすべてのデータは同じ物理パーティション内に存在する必要があるためです。 ここでは、別のパーティション キー戦略を採用する必要があります。  
* **t*N** を超えるスループットをプロビジョニングすると、そのスループット引き上げに対応するために、既存の物理パーティションが Azure Cosmos DB によって分割されます。

パーティション キーのセマンティクスは、次の表に示したように、API ごとのセマンティクスに応じて若干異なります。

| API | パーティション キー | 行キー |
| --- | --- | --- |
| SQL | カスタム パーティション キーのパス | `id` (固定) | 
| MongoDB | カスタム シャード キー  | `_id` (固定) | 
| Gremlin | カスタム パーティション キーのプロパティ | `id` (固定) | 
| テーブル | `PartitionKey` (固定) | `RowKey` (固定) | 

Azure Cosmos DB には、ハッシュベースのパーティション分割が使用されています。 何か項目を書き込むと、Azure Cosmos DB がパーティション キー値をハッシュし、そのハッシュした結果を基に項目の格納先のパーティションを決定します。 

> [!NOTE]
> 同じパーティション キーを備えた項目はすべて同じ物理パーティションに格納されます。 

## <a name="best-practices-when-choosing-a-partition-key"></a>パーティション キーを選択する際のベスト プラクティス

パーティション キーの選択は、設計時に行う必要のある重要な決定事項の 1 つです。 値が多岐にわたっていて、なおかつ均等なアクセス パターンを持ったプロパティ名を選択します。 多数の個別の値 (数百や数千など) を持つパーティション キーにすることをお勧めします。 これらの値の間でワークロードを均等に分散配置できます。 理想的なパーティション キーとは、クエリ内でフィルターとして頻繁に使用され、ソリューションのスケーラビリティを確保するために十分なカーディナリティを持つものを指します。

物理パーティションがその容量の上限に達し、パーティション内のデータのパーティション キーが同一である場合、Azure Cosmos DB は "*パーティション キーは、10 GB の最大サイズに達した*" というメッセージを返し、パーティションは分割されません。 適切なパーティション キーを選択することは、非常に重要な意思決定です。 

次のようにパーティション キーを選択します。

* すべてのキーでストレージの配分が同じになるようにする。  
* すべてのキーで特定の時点における要求のボリュームの配分が同じになるようにする。  

  パーティション間でデータがどのように分散されているかを確認することが大切です。 ポータルでデータの分散を確認するには、Azure Cosmos DB アカウントに移動して、**[監視]** セクションの **[メトリック]** をクリックし、**[ストレージ]** タブをクリックして、異なる物理パーティション間でデータがどのように分散されているかを確認します。

  ![リソースのパーティション分割](./media/partition-data/partitionkey-example.png)

  上図の左側の画像は不適切なパーティション キーの結果を、上図の右側の画像は適切なパーティション キーが選ばれた場合の結果を示しています。 左側の画像では、パーティション間でデータが均等に分散されていないことがわかります。 右側の画像と同様になるように、データを分散配置するパーティション キーを選択する努力が必要です。

* フィルターの述語にパーティション キーを含めることで、同時実行数の多いクエリ呼び出しが効率的にルーティングされるようにする。  
* より高いカーディナリティを持つパーティション キーを選択することが望ましい。そのほうが一般的により優れた配分やスケーラビリティを発揮するためです。 たとえば、カーディナリティを向上させる複数のプロパティの値を結合して、合成キーを形成できます。  

上記の考慮事項に基づいてパーティション キーを選択する際には、パーティションの数や各物理パーティションに割り当てられるスループットの量について心配する必要はありません。Azure Cosmos DB が物理パーティションの数をスケールアウトし、必要に応じて個々のパーティションのスケールします。

<a name="prerequisites"></a>
## <a name="prerequisites-for-partitioning"></a>パーティション分割の前提条件

Azure Cosmos DB コンテナーは、Azure Portal で固定または無制限として作成できます。 固定サイズのコンテナーの上限は、容量が 10 GB で、スループットが毎秒 10,000 RU となります。 コンテナーを無制限として作成する場合は、スループットに最低でも 1,000 RU/秒を指定する必要があります。 Azure Cosmos DB コンテナーが、一連のコンテナー間でスループットを共有するように構成されていることもあります。この場合、各コンテナーがパーティション キーを指定する必要があります。また、これらのコンテナーは無制限に拡張できます。 以下に、パーティション分割とスケーリングを検討するための前提条件を示します。

* Azure Portal でコンテナー (コレクション、グラフ、またはテーブルなど) を作成するときに、**無制限**ストレージ容量オプションを選択して、無制限スケーリングを利用します。 物理パーティションを「[パーティション分割のしくみ](#how-does-partitioning-work)」で説明されているように **p1** と **p2** に自動分割するには、1,000 RU/秒以上のスループットでコンテナーを作成 (または、一連のコンテナー間でスループットを共有) する必要があります。また、パーティション キーを指定する必要もあります。 

* Azure Portal またはプログラムでコンテナーを作成し、初期スループットが 1,000 RU/秒以上ある状態で、パーティション キーを指定した場合、コンテナーに対して無料で無制限スケーリングを利用できます。 初期コンテナーが少なくとも 1,000 RU/秒のスループットで作成済みで、かつ、パーティション キーが指定されているかぎり、これには**固定**コンテナーが含まれます。

* 一連のコンテナー の一部としてスループットを共有するように構成されたコンテナーすべてが、**無制限**コンテナーとして処理されます。

パーティションキーなし、または 1,000 RU/s 未満のスループットで**固定**コンテナーを作成した場合、コンテナーは自動的にスケーリングされません。 固定コンテナーから無制限のコンテナーにデータを移行するには、[データ移行ツール](import-data.md)または[変更フィード ライブラリ](change-feed.md)を使用する必要があります。 

## <a name="partitioning-and-provisioned-throughput"></a>パーティション分割とプロビジョニング済みスループット
Azure Cosmos DB は、予測可能なパフォーマンスが得られるように設計されています。 1 つのコンテナーまたは一連のコンテナーを作成するときに、"*1 秒あたりの [要求ユニット](request-units.md) (RU)*" でスループットを予約します。 各要求では、操作で使用されるシステム リソースの量 (CPU、メモリ、IO など) に比例する、RU の負担が発生します。 セッション整合性での 1 KB のドキュメントの読み取りでは、1 RU を使用します。 読み取りは、格納された項目の数や、同時に実行する同時要求の数にかかわらず 1 RU になります。 サイズの大きい項目では、サイズに応じた、さらに多くの RU が必要になります。 アプリケーションにサポートする必要のあるエンティティのサイズと読み取りの数がわかっている場合は、アプリケーションのニーズに見合う正確な量のスループットをプロビジョニングできます。 

> [!NOTE]
> 1 つのコンテナーまたは一連のコンテナーに対してプロビジョニングされたスループットをフルに活用するには、個々のパーティション キー値の間で要求を均等に分散できるパーティション キーを選択する必要があります。
> 
> 

<a name="designing-for-partitioning"></a>
## <a name="create-partition-key"></a>パーティション キーを作成する 
コンテナーは、Azure Portal または Azure CLI を使って作成し、いつでもスケーリングすることができます。 このセクションでは、コンテナーを作成し、各 API を使ってプロビジョニングされたスループットとパーティション キーを指定する方法を紹介します。


### <a name="sql-api"></a>SQL API
次のサンプルは、SQL API を使ってコンテナー (コレクション) を作成する方法を示しています。 

```csharp
DocumentClient client = new DocumentClient(new Uri(endpoint), authKey);
await client.CreateDatabaseAsync(new Database { Id = "db" });

DocumentCollection myCollection = new DocumentCollection();
myCollection.Id = "coll";
myCollection.PartitionKey.Paths.Add("/deviceId");

await client.CreateDocumentCollectionAsync(
    UriFactory.CreateDatabaseUri("db"),
    myCollection,
    new RequestOptions { OfferThroughput = 20000 });
```

項目 (ドキュメント) の読み取りは、REST API の `GET` メソッドを使うか、いずれかの SDK の `ReadDocumentAsync` を使って行うことができます。

```csharp
// Read document. Needs the partition key and the ID to be specified
DeviceReading document = await client.ReadDocumentAsync<DeviceReading>(
  UriFactory.CreateDocumentUri("db", "coll", "XMS-001-FE24C"), 
  new RequestOptions { PartitionKey = new PartitionKey("XMS-0001") });
```

詳細については、「[SQL API を使用した Azure Cosmos DB でのパーティション分割](sql-api-partition-data.md)」をご覧ください。

### <a name="mongodb-api"></a>MongoDB API
MongoDB API を使用すると、お気に入りのツールやドライバー、SDK を通じてシャード コレクションを作成できます。 この例では、Mongo シェルを使用してコレクションを作成します。

Mongo シェルで次のコマンドを実行します。

```
db.runCommand( { shardCollection: "admin.people", key: { region: "hashed" } } )
```
    
結果:

```JSON
{
    "_t" : "ShardCollectionResponse",
    "ok" : 1,
    "collectionsharded" : "admin.people"
}
```

### <a name="table-api"></a>テーブル API

Table API を使用してテーブルを作成するには、`CreateIfNotExists` メソッドを使用します。 

```csharp
CloudTableClient tableClient = storageAccount.CreateCloudTableClient();

CloudTable table = tableClient.GetTableReference("people");
table.CreateIfNotExists(throughput: 800);
```

プロビジョニングされたスループットは、`CreateIfNotExists` の引数として設定されます。 パーティション キーは、`PartitionKey` 値として暗黙的に作成されます。 

単一のエンティティを取得するには、次のコードを使用します。

```csharp
// Create a retrieve operation that takes a customer entity.
TableOperation retrieveOperation = TableOperation.Retrieve<CustomerEntity>("Smith", "Ben");

// Execute the retrieve operation.
TableResult retrievedResult = table.Execute(retrieveOperation);
```
詳細については、[テーブル API を使用した開発](tutorial-develop-table-dotnet.md)に関するページを参照してください。

### <a name="gremlin-api"></a>Gremlin API

Gremlin API を使用すると、Azure Portal または Azure CLI を使って、グラフを表すコンテナーを作成できます。 また、Azure Cosmos DB はマルチモデルであるため、他のいずれかの API を使ってグラフ コンテナーを作成したりスケーリングしたりできます。

Gremlin では、パーティション キーと ID を使って頂点または辺を読み取ることができます。 たとえばリージョン ("USA") をパーティション キー、"Seattle" を行キーとするグラフの場合、頂点は次の構文で見つけることができます。

```
g.V(['USA', 'Seattle'])
```

辺は、パーティション キーと行キーを使って参照することができます。

```
g.E(['USA', 'I5'])
```

詳細については、「[Azure Cosmos DB でのパーティション分割されたグラフの使用](graph-partitioning.md)」をご覧ください。

## <a name="form-partition-key-by-concatenating-multiple-fields"></a>複数のフィールドを結合してパーティション キーを形成する

複数のプロパティ値を結合して、項目の単一の人工 "partitionKey" プロパティにパディングすることで、1 つのパーティション キーを形成することもできます。 これらのキーは合成キーと呼ばれます。

たとえば、次のようなドキュメントがあります。

```json
{
"deviceId": "abc-123",
"date": 2018
}
```

オプションとして、/deviceId または /date に partitionKey を設定します。 デバイス ID と日付でパーティション キーを形成したい場合は、 これら 2 つの値を人工 "partitionKey" プロパティに結合し、パーティション キーを /partitionKey に設定します。

```json
{
"deviceId": "abc-123",
"date": 2018,
"partitionKey": "abc-123-2018"
}
```

実際のシナリオでは、多数のドキュメントを保持する可能性があるため、複数の値を合成キーに結合し、その合成キーをドキュメントに挿入してからパーティション キーの指定に使用するように、クライアント側のロジックを定義する必要があります。

<a name="designing-for-scale"></a>
## <a name="design-for-scale"></a>スケールの設計
Azure Cosmos DB のスケーリングを効率よく行うには、コンテナーを作成する際に適切なパーティション キーを選ぶ必要があります。 適切なパーティション キーを選ぶ際の主な考慮事項は、次の 2 つです。

* **クエリ境界とトランザクション**。 パーティション キーを選ぶ際は、トランザクションを使用すると同時に、ソリューションのスケーラビリティ確保のためにエンティティを複数のパーティション キーに分散させることができるような、バランスの取れた条件にする必要があります。 極端な例を挙げると、すべての項目に同じパーティション キーを設定することは可能ですが、この場合はソリューションのスケーラビリティが制限される可能性があります。 その一方で、それぞれの項目に対して固有のパーティション キーを割り当てることもできます。 この場合、スケーラビリティは向上するものの、ストアド プロシージャとトリガーを介したクロス ドキュメント トランザクションを使用できなくなります。 理想的なパーティション キーは、効率的なクエリの使用を可能にし、かつソリューションのスケーラビリティを確保するために十分なカーディナリティを備えています。 
* **ストレージとパフォーマンスのボトルネックがない**。 ばらばらに存在する各種の値に対して書き込みを分散できるようなプロパティを選ぶことが重要です。 同じパーティション キーへの要求は、パーティションに割り当てられているプロビジョニングされたスループットを超えることはできず、レート制限が課されます。 そのため、アプリケーション内の "ホット スポット" にならないパーティション キーを選択することが重要です。 1 つのパーティション キーのすべてのデータをパーティション内に格納する必要があるため、同じ値のデータが大量にあるパーティション キーは使用しないようにすることをお勧めします。 

実際に遭遇する可能性のあるいくつかのシナリオと、それぞれの適切なパーティション キーを見てみましょう。
* ユーザー プロファイルのバックエンドを実装する場合、パーティション キーの選択として "*ユーザー ID*" が適しています。
* IoT データ (デバイス状態など) を格納する場合は、パーティション キーの選択として "*デバイス ID*" が適しています。
* 時系列データのログ記録に Azure Cosmos DB を使用している場合は、パーティション キーの選択として "*ホスト名*" または "*プロセス ID*" が適しています。
* マルチテナント アーキテクチャがある場合は、パーティション キーの選択として "*テナント ID*" が適しています。

一部のユース ケース (IoT およびユーザー プロファイルなど) では、パーティション キーはお使いの *ID* (ドキュメント キー) と同じになる場合があります。 時系列データなどの他のケースでは、パーティション キーは *ID* と異なる可能性があります。

### <a name="partitioning-and-loggingtime-series-data"></a>パーティション分割とログ記録/時系列データ
Azure Cosmos DB の一般的なユース ケースの 1 つは、ログ記録とテレメトリです。 膨大な量のデータの読み取り/書き込みが必要になる場合があるため、このシナリオに適したパーティション キーを選択することが重要です。 選択するパーティション キーは、実行する予定のクエリの読み取り速度、書き込み速度、種類によって決まります。 適切なパーティション キーを選択する方法に関するヒントを次に示します。

* 長期間に少量の書き込みが累積して、タイム スタンプの範囲ごとにその他のフィルターを使ったクエリが必要になるユース ケースでは、タイム スタンプのロールアップを使用します。 たとえば、日付をパーティション キーとして使用することをお勧めします。 この方法により、1 つのパーティションから指定日のすべてのデータを照会できます。 
* このシナリオでは非常に一般的な、ワークロードの書き込み量が多いケースでは、タイムスタンプに基づかないパーティション キーを使用します。 これにより、Azure Cosmos DB が複数のパーティション間で均等に書き込みを分散することができます。 この場合は、"*ホスト名*"、"*プロセス ID*"、"*アクティビティ ID*"、または高カーディナリティの他のプロパティが適しています。 
* もう 1 つの方法は、複数コンテナーがあるハイブリッドです。この場合には、日または月ごとに 1 つのコンテナーがあり、パーティション キーは、"*ホスト名*" のようにより細分化されたプロパティです。 この方法の利点は、時間枠、スケール、およびパフォーマンスのニーズに基づいて、各コンテナーまたは一連のコンテナーに対して異なるスループットを設定できることです。 たとえば、現在の月のコンテナーは、読み取りと書き込みに対応するため高スループットでプロビジョニングできます。 過去の月の場合は、読み取りのみに対応するため、低いスループットでプロビジョニングできます。

### <a name="partitioning-and-multitenancy"></a>パーティション分割とマルチテナント方式
Azure Cosmos DB を使用したマルチテナント アプリケーションを実装する場合、一般に 2 つの設計を検討します。"*テナントごとに 1 つのパーティション キーを使用する方法*" と、"*テナントごとに 1 つのコンテナーを使用する方法*" です。 それぞれの長所と短所は次のとおりです。

* **テナントあたり 1 つのパーティション キー**。 このモデルでは、テナントは、単一のコンテナー内に併置されます。 1 つのテナントに対するクエリや挿入は、1 つのパーティションに対して実行できます。 また、1 つのテナントに属するすべての項目にわたってトランザクション ロジックを実装することも可能です。 複数のテナントで 1 つのコンテナーが共有されるため、各テナント用にプロビジョニングするのではなく、単一のコンテナー内のすべてのテナントのリソースをプールすることで、ストレージとプロビジョニングされたスループットをより的確に利用できます。 欠点は、テナントごとにパフォーマンスを分離できないことです。 パフォーマンスを保証するためにスループットを向上させると、すべてのテナントを備えたコンテナー全体に適用され、個々のテナントで対象を向上させる場合とは対照的になります。
* **テナントあたり 1 つのコンテナー**。 このモデルでは、各テナントが独自のコンテナーを備え、テナントごとに保証されたパフォーマンスでスループットを予約できます。 このモデルでは、少数のテナントを含んだマルチテナント アプリケーションでより高いコスト効果が得られます。

また、ハイブリッドな手法を使用して、小規模なテナントを併置したり、より大規模なテナントを自身のコンテナーに分離したりすることもできます。

## <a name="next-steps"></a>次の手順
この記事では、Azure Cosmos DB におけるスケーリングとパーティション分割の概念とベスト プラクティスについて概説しました。 

* [Azure Cosmos DB におけるスループットのプロビジョニング](request-units.md)について理解します。
* [Azure Cosmos DB の世界規模での分散](distribute-data-globally.md)について理解します。



