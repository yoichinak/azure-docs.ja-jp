---
title: Azure Storage Table 設計ガイド | Microsoft Docs
description: Azure テーブル ストレージでスケーラビリティとパフォーマンスに優れたテーブルを設計する
services: cosmos-db
author: SnehaGunda
manager: kfile
ms.service: cosmos-db
ms.component: cosmosdb-table
ms.devlang: na
ms.topic: conceptual
ms.date: 11/03/2017
ms.author: sngun
ms.openlocfilehash: bb1c59fa7df9cf466ce1fd7f32f08d255fe656bd
ms.sourcegitcommit: d7725f1f20c534c102021aa4feaea7fc0d257609
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/29/2018
ms.locfileid: "37097065"
---
# <a name="azure-storage-table-design-guide-designing-scalable-and-performant-tables"></a>Azure ストレージ テーブルの設計ガイド: スケーラブルな設計とハイパフォーマンスなテーブル
[!INCLUDE [storage-table-cosmos-db-tip-include](../../includes/storage-table-cosmos-db-tip-include.md)]

スケーラビリティとパフォーマンスに優れたテーブルを設計するにあたっては、さまざまな事柄を考慮する必要があります。具体的にはパフォーマンス、スケーラビリティ、コストなどですが、 過去にリレーショナル データベースのスキーマを設計した経験がある方なら、こうした考慮事項はご存じであると思われます。しかし、Azure Table service ストレージ モデルとリレーショナル モデルには類似の要素が多いとはいえ、重要な違いが多数あるのも事実です。 こうした相違点は、リレーショナル データベースの扱いに慣れた方には直感的にわかりづらかったり、扱いづらかったりする設計につながりがちですが、Azure Table service などの NoSQL キー/値ストアを設計する場合には好都合です。 設計の相違点の多くは、Table service が何十億ものデータ エンティティ (リレーショナル データベース用語では行) を含むクラウド アプリケーションをサポートするためのデータや、大量のデータトランザクションをサポートするよう設計されている 点を考慮します。そのため、データの格納方法や Table service の動作方法について違った考え方が必要になります。 NoSQL データ ストアを適切に設計すれば、リレーショナル データベースを使うソリューションよりも、ソリューションのスケーラビリティが大幅に高まり、コストも抑えられます。 このガイドでは、これらのトピックについて説明します。  

## <a name="about-the-azure-table-service"></a>Azure Table service
このセクションでは、パフォーマンスとスケーラビリティを重視した設計に関連する Table service の主要機能を取り上げます。 初めて Azure Storage と Table service をご利用になる場合は、この文書を読み進める前に、「[Microsoft Azure Storage の概要](../storage/common/storage-introduction.md)」と「[.NET を使用して Azure Table Storage を使用する](table-storage-how-to-use-dotnet.md)」をお読みください。 このガイドで主に取り上げるのは Table service についてですが、Azure のキューや Blob service と、それらのサービスをソリューションで Table service と共に使用する方法についても触れます。  

Table service とは 名前が示すとおり、Table service ではデータの格納にテーブル形式を使います。 名前からおわかりのように、Table service は表形式を使用してデータを格納します。 各エンティティは、それ自体を一意に識別するためのキーのペアと、Table サービスがエンティティの最終更新日時をトラッキングするためのタイムスタンプ列を持ちます (エンティティの更新は自動的に行われます。 各エンティティには、エンティティを識別する一意のキー ペア、エンティティが最後に更新された日時を追跡するために Table service によって使用されるタイムスタンプ列が含まれます (タイムスタンプ フィールドは自動的に追加されるため、タイムスタンプを任意の値を使って手動で上書きすることはできません)。 Table service では、この最終更新日時のタイムスタンプ (LMT) を使ってオプティミスティック同時実行を管理します。  

> [!NOTE]
> Table service REST API 操作により、最終更新タイムスタンプ (LMT) から派生する **ETag** 値も返されます。 このドキュメントでは、ETag と LMT という用語を区別なく使います。基となる同じデータを表しているためです。  
> 
> 

次の例は、従業員と部署のエンティティを格納する、シンプルなテーブル設計を示しています。 このガイドで紹介する例の多くは、このシンプルな設計が基になっています。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td>Marketing</td>
<td>00001</td>
<td>2014-08-22T00:50:32Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Don</td>
<td>Hall</td>
<td>34</td>
<td>donh@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>00002</td>
<td>2014-08-22T00:50:34Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Jun</td>
<td>Cao</td>
<td>47</td>
<td>junc@contoso.com</td>
</tr>
</table>
</tr>
<tr>
<td>Marketing</td>
<td>部署</td>
<td>2014-08-22T00:50:30Z</td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>Marketing</td>
<td>153</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>Sales</td>
<td>00010</td>
<td>2014-08-22T00:50:44Z</td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Ken</td>
<td>Kwok</td>
<td>23</td>
<td>kenk@contoso.com</td>
</tr>
</table>
</td>
</tr>
</table>


今のところ、この設計は、リレーショナル データベースのテーブルと非常によく似ており、異なるキーが必須の列となっていて、同じテーブルに複数の種類のエンティティを格納できます。 さらに、**FirstName** や **Age** などのユーザー定義プロパティには、リレーショナル データベース内の列のように、整数や文字列などのデータ型があります。 ただし、リレーショナル データベースとは違って、Table service にはスキーマがないため、エンティティごとにプロパティのデータ型は同じである必要ありません。 1 つのプロパティに複雑なデータ型を格納するには、JSON や XML などのシリアル化された形式を使う必要があります。 サポート対象のデータ型と日付の範囲、名付け規則、サイズ制限などの Table サービスの詳細については、「 [Table サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx)」を参照してください。

お分かりかと思いますが、テーブル デザインの基盤には、**PartitionKey** と **RowKey** の選択が適しています。 テーブルに格納されている各エンティティは、**PartitionKey** と **RowKey** の一意の組み合わせである必要があります。 リレーショナル データベース テーブル内のキーと同様に、**PartitionKey** と **RowKey** の値には、高速検索を可能にするクラスター化インデックスを作成するためのインデックスが作成されています。ただし、Table service はセカンダリ インデックスを作成しないため、これら 2 つだけがインデックス付きプロパティとなります (制限については、数パターンを後述しています)。  

テーブルは 1 つまたは複数のパーティションから構成されており、ソリューションを最適化するためには、適切な **PartitionKey** と **RowKey** を選択して設計を決定します。 ソリューションによっては、すべてのエンティティがパーティションを使って整理された 1 つのテーブルだけで構成されるものもありますが、通常は複数のテーブルが含まれます。 テーブルを使えばエンティティを論理的に整理できるほか、アクセス制御リストを使ってデータへのアクセスを管理できます。また、1 回のストレージ操作でテーブル全体を削除できます。  

### <a name="table-partitions"></a>テーブルのパーティション
アカウント名、テーブル名、**PartitionKey** を組み合わせ、テーブル サービスがエンティティを格納する場所をストレージ サービス内のパーティションに特定します。 エンティティのアドレス指定スキームの一部であると同時に、パーティションはトランザクションのスコープが定義 し(下記の [エンティティ グループ トランザクション](#entity-group-transactions) を参照してください)、テーブル サービスのスケーラビリティを形成します。 パーティションの詳細については、「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット](../storage/common/storage-scalability-targets.md)」を参照してください。  

Table service では、個々のノードが 1 つ以上の完全なパーティションを提供し、サービスのスケーリングはノード間でパーティションの負荷を動的に分散させることで行われます。 ノードに負荷がかかる場合は、テーブル サービスのパーティション範囲を 別のノードと*分割*し、トラフィックが少ないときにサービスを*マージ*して、パーティション範囲を複数のトラフィックの少ないノードから 1 つのノードに戻すことができます。  

Table service の内部詳細、特に、サービスのパーティション管理方法については、ホワイト ペーパー [Microsoft Azure のストレージ: 強力な一貫性を備えた高使用可能なクラウド ストレージ サービス](http://blogs.msdn.com/b/windowsazurestorage/archive/2011/11/20/windows-azure-storage-a-highly-available-cloud-storage-service-with-strong-consistency.aspx)を参照してください。  

### <a name="entity-group-transactions"></a>エンティティ グループ トランザクション
エンティティ グループ トランザクション (EGT) は、Table service で複数のエンティティ間でアトミックな更新を行うための唯一の組み込みのメカニズムです。 EGT は、一部のドキュメントでは*バッチ トランザクション*とも呼ばれています。 EGT では、同じパーティションに格納されたエンティティしか処理できないため (特定のテーブルで同じパーティション キーを共有)、複数のエンティティにまたがるアトミックなトランザクションが必要な場合は、それらのエンティティを同じパーティションに格納する必要があります。 これが、異なる種類のエンティティに複数のテーブルを使わずに、異なる種類のエンティティを同じテーブル (とパーティション) に格納する主な理由です。 単一の EGT で最大 100 個のエンティティを処理できます。  複数の並行処理 EGT を送信する場合は、それらの EGT が EGT 間の共通であるエンティティには動作しないことを確認することが重要です。さもないと、処理が遅くなる可能性があります。

EGT により、設計で評価が必要なトレードオフが生じる可能性もあります。使用するパーティションが増えると、ノード間で要求を負荷分散しやすくなるため、アプリケーションのスケーラビリティが向上するものの、アプリケーションでアトミックなトランザクションを実行し、データの強力な一貫性を維持する力が限られるおそれがあります。 さらに、1 つのノードの予想されるトランザクションのスループットを制限する、パーティション レベルの特定のスケーラビリティ ターゲットがあります。Azure Storage アカウントと Table サービスのスケーラビリティ ターゲットの詳細については、「[Azure Storage のスケーラビリティおよびパフォーマンスのターゲット](../storage/common/storage-scalability-targets.md)」をご覧ください。 このガイドの後のセクションでは、このようなトレードオフを管理しやすくするさまざまな設計戦略を紹介すると共に、クライアント アプリケーションの固有の要件に基づいてパーティション キーを選択する最適な方法についても説明します。  

### <a name="capacity-considerations"></a>容量に関する考慮事項
次の表に、Table service ソリューションの設計時に考慮する必要のある主要な値をまとめます。  

| Azure ストレージ アカウントの合計容量 | 500 TB |
| --- | --- |
| Azure のストレージ アカウントのテーブルの数 |ストレージ アカウントの容量のみによる制限 |
| テーブルのパーティションの数 |ストレージ アカウントの容量のみによる制限 |
| パーティション内のエンティティの数 |ストレージ アカウントの容量のみによる制限 |
| 個別のエンティティのサイズ |1 MBまでの最大 255 個のプロパティ (**PartitionKey**、**RowKey**、**タイムスタンプ**を含む) |
| **PartitionKey** |最大 1 KB の文字列 |
| **RowKey** |最大 1 KB の文字列 |
| エンティティ グループ トランザクションのサイズ |トランザクションには最大で 100 個のエンティティを含めることができ、ペイロードは 4 MB 未満にする必要があります。 EGT では 1 回に 1 つのエンティティしか更新できません。 |

詳細については、「 [Table サービス データ モデルについて](http://msdn.microsoft.com/library/azure/dd179338.aspx)」を参照してください。  

### <a name="cost-considerations"></a>コストに関する考慮事項
テーブル ストレージは比較的安価ですが、Table service を使うソリューションの評価の一環として、容量の使用とトランザクションの量を踏まえてコストを見積もる必要があります。 ただし、多くのシナリオでは、ソリューションのパフォーマンスとスケーラビリティを向上させるために、非正規化されたデータまたは重複するデータを格納するのも有効です。 価格の詳細については、「 [Azure Storage 料金](https://azure.microsoft.com/pricing/details/storage/)」を参照してください。  

## <a name="guidelines-for-table-design"></a>テーブル設計のガイドライン
これらのリストにはテーブルを設計する際の主要なガイドラインがまとめられており、これらガイドは後ほど詳細にテーブルへの対処方法を説明します。 これらのガイドラインは、リレーショナル データベースの設計のために通常参照するガイドラインとは異なります。  

Table service ソリューションを効率的に *読み込む* 設計：

* ***読み込みが多いアプリケーションでクエリを実行するための設計*** テーブルを設計するときは、エンティティの更新方法について考える前に、実行するクエリ (特に、待機時間に影響を受けやすいもの) を検討してください。 これは通常、効率的でパフォーマンスの高いソリューションになります。  
* ***クエリでは、PartitionKey と RowKey の両方を指定します。*** *ポイント クエリ* これらは、最も効率的なテーブル サービスのクエリなどです。  
* ***エンティティの重複コピーを格納するか検討します。*** テーブル ストレージは安価であるため、クエリの効率を上げるため、(異なるキーを持つ) 同じエンティティを複数回格納することをご検討ください。  
* ***データの非正規化を検討します。*** テーブル ストレージは安価であるため、データの非正規化を検討してください。 たとえば、概要エンティティを格納すると、統計データ用クエリは単一のエンティティにアクセスするだけで済みます。  
* ***複合キーの値を使用します。*** 使用可能なキーは、**PartitionKey** と **RowKey** のみです。 たとえば、複合キーの値を使用してエンティティへの代替キー付きアクセス パスを有効にします。  
* ***クエリ プロジェクションを使用します。*** 必要なフィールドだけを選択するクエリを使用して、ネットワーク経由で転送するデータ量を削減できます。  

効果的に *書き込む* Table service ソリューションを設計する。  

* ***ホット パーティションを作成しないでください。*** 任意の時点で、複数のパーティションで要求を分散できるキーを選択します。  
* ***トラフィックの急増を回避します。*** 適切な期間でトラフィックの流れをスムーズにし、トラフィックの急増を回避します。
* ***必ずしもエンティティの種類ごとに個別のテーブルを作成する必要はありません。*** 複数のエンティティ種類でアトミック トランザクションが必要なときに、同じテーブル内の同じパーティションにこれら複数のエンティティ種類を格納できます。
* ***実現する必要のある最大スループットを検討します。*** Table service のスケーラビリティ ターゲットを確認し、それを超えない設計にする必要があります。  

このガイドでは、これらの原則を実装した例を紹介します。  

## <a name="design-for-querying"></a>クエリに対応した設計
Table service ソリューションでは、読み取り、書き込み、またはその両方の負荷が高くなることがあります。 このセクションでは、読み取り操作を効率的に行える Table service を設計する際に注意する必要のある事柄を中心に取り上げます。 通常は、読み取り操作を効率的にサポートする設計は、書き込み操作についても効率が高くなります。 ただし、書き込み操作をサポートする設計には、さらに考慮すべき事柄があります。次のセクション「[データの変更に対応した設計](#design-for-data-modification)」で説明します。

データを効率的に読み取ることのできる Table service ソリューションを設計する際には、まず "必要なデータを Table service から取得するには、アプリケーションでどのようなクエリを実行する必要があるか" を考えてみてください。  

> [!NOTE]
> Table service を使用する場合は、事前に正しく設計することが重要です。後で設計を変更するのは難しいだけでなく、コストも高くなるためです。 たとえば、リレーショナル データベースなら、既存のデータベースにインデックスを追加するだけでパフォーマンスの問題に対処できるのが普通ですが、Table service ではそうはいきません。  
> 
> 

このセクションでは、クエリに対応したテーブルを設計する際に対処する必要のある主要な問題を中心に取り上げます。 このセクションで取り上げるトピックは次のとおりです。

* [選択した PartitionKey と RowKey がクエリのパフォーマンスに与える影響](#how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance)
* [適切な PartitionKey の選択](#choosing-an-appropriate-partitionkey)
* [クエリを Table service 向けに最適化する](#optimizing-queries-for-the-table-service)
* [Table service でデータを並べ替える](#sorting-data-in-the-table-service)

### <a name="how-your-choice-of-partitionkey-and-rowkey-impacts-query-performance"></a>選択した PartitionKey と RowKey がクエリのパフォーマンスに与える影響
次の例は、以下の構造を持った複数の従業員エンティティの格納を想定しています (明確にするためほとんどの例で **タイムスタンプ** プロパティを省略)。  

| *列名* | *データの種類* |
| --- | --- |
| **PartitionKey** (部門名) |String |
| **RowKey** (従業員 ID) |String |
| **FirstName** |String |
| **LastName** |String |
| **Age** |整数 |
| **EmailAddress** |String |

最初の方のセクション「[Azure Table service の概要](#overview)」では、クエリの設計に直接影響を与える Azure Table service の主な機能の一部について説明します。 ここから、Table service のクエリを設計する際には、次のような一般的なガイドラインが考えられます。 以下の例で使用しているフィルター構文は、Table service REST API の構文です。詳細については、「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」(エンティティの照会) を参照してください。  

* ***ポイント クエリ***は、最も効率的な検索です。大量の参照または短い待機時間が求められる参照に使用することをお勧めします。 このようなクエリでは、**PartitionKey** と **RowKey** 値の両方を指定することでインデックスを使用し、個別のエンティティを効率よく検索することができます。 例: $filter (PartitionKey eq 'Sales') = および (RowKey eq '2')  
* 2 番目に良い方法は、**PartitionKey** を使用する***範囲クエリ***と、**RowKey 値**の範囲にフィルターをかけ、1 つ以上のエンティティを返す です。 **PartitionKey** 値は特定のパーティションを識別し、**RowKey** 値はそのパーティション内のエンティティのサブセットを識別します。 例: $filter=PartitionKey eq 'Sales' および RowKey ge 'S' および RowKey lt 'T'  
* 3 番目に良い方法は、**PartitionKey** を使用し、他のキーを持たないプロパティにフィルターをかけ、1 つ以上のエンティティを返すことが可能な***パーティション スキャン***です。 **PartitionKey** 値は特定のパーティションを識別し、プロパティ値はそのパーティション内のエンティティのサブセットを選択します。 例: $filter = PartitionKey eq '販売'、および LastName eq 'Smith'  
* ***テーブル スキャン***に **PartitionKey** は含まれません。また、一致するエンティティのテーブルを構成するパーティションのすべてを検索するため、非効率的です。 フィルターが **RowKey** を使用する / しないに関わりなく、テーブルのスキャンが実行されます。 例: $filter = LastName eq 'Jones'  
* クエリは複数のエンティティを **PartitionKey** と **RowKey** の順序で並べ替えて返します。 クライアント内でエンティティを再度並べ替えるのを防ぐため、最も一般的な並べ替え順序を定義する **RowKey** を選択します。  

"**or**" を使用して **RowKey** 値に基づいてフィルターを指定した場合はパーティション スキャンが行われます。範囲クエリとしては扱われません。 そのため、$filter = PartitionKey eq 'Sales' and (RowKey eq '121' or RowKey eq '322') のようなフィルターを使用するクエリの使用は避ける必要があります。  

ストレージ クライアント ライブラリを使って効率的なクエリを実行するクライアント側コードの例については、  

* [ストレージ クライアント ライブラリを使ってポイント クエリを実行する](#executing-a-point-query-using-the-storage-client-library)
* [LINQ を使用して複数のエンティティを取得します。](#retrieving-multiple-entities-using-linq)
* [サーバー側のプロジェクション](#server-side-projection)  

同じテーブルに格納された複数の種類のエンティティを処理できるクライアント側コードの例については、  

* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)  

### <a name="choosing-an-appropriate-partitionkey"></a>適切な PartitionKey の選択
選択した **PartitionKey** は複数のパーティションでエンティティを配布するための要件に対し (一貫性を確保するため) EGT の使用を可能にするため、必要性のバランスを取る必要があります (スケーラブルなソリューションの確保のため)。  

すべてのエンティティを 1 つのパーティションに格納することも可能ですが、そうするとソリューションのスケーラビリティが制限され、Table サービスで要求を負荷分散できなくなる可能性があります。 逆に、パーティションごとに 1 つのエンティティを格納することもできます。このようにすると、スケーラビリティが高まり、Table service で要求を負荷分散できるようになるものの、エンティティ グループ トランザクションは使用できなくなります。  

理想的な **PartitionKey** とは、効率的なクエリを使用することができ、スケーラブルなソリューションを確保できるパーティションを持つものを指します。 通常、エンティティには、十分な数のパーティションにエンティティを分散できるだけのプロパティがあります。

> [!NOTE]
> たとえば、ユーザーまたは従業員に関する情報を格納するシステムでは、ユーザー ID を PartitionKey として使うと便利です。 パーティション分割キーとして所定の UserID を使用する複数のエンティティを使用できます。 あるユーザーに関するデータを保存するそれぞれのエンティティは 1 つのパーティションにグループ化されるため、高い拡張性を確保しながら、エンティティ グループ トランザクションを介してこれらのエンティティにアクセスできます。
> 
> 

選択した **PartitionKey** についてエンティティの挿入、更新、削除方法に関連する追加の検討事項があります。下記の[データ変更のための設計](#design-for-data-modification)のセクションをご覧ください。  

### <a name="optimizing-queries-for-the-table-service"></a>クエリを Table service 向けに最適化する
Table service は 1 つのクラスター化インデックス内の **PartitionKey** と **RowKey** 値を使用して自動的にインデックスを作成します。そのため、そのためポイント クエリが使用するには最も効果的です。 ただし、**PartitionKey** と **RowKey** のクラスター化インデックス以外にはインデックスはありません。

多くの設計は、複数の条件に基づいてエンティティをルックアップできるようにするという要件を満たす必要があります。 たとえば、電子メール、従業員 ID、姓に基づいて従業員エンティティを特定する場合などです。 セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) ではこれらの要件の種類について説明し、また、Table service がセカンダリ インデックスを提供しないことへの対処方法について説明します。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) -異なる **RowKey** 値 (同じパーティション) を使用して各エンティティの複数のコピーを格納し、異なる **RowKey** 値を使用して効果的な検索と代替的な並べ替え順序を可能にします。  
* [パーティション内のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - 別個のパーティションまたは別個のテーブルの異なる **RowKey** 値を使用して各エンティティの複数のコピーを格納し、異なる **RowKey** 値を使用して高速で効率的な検索と代替的な並べ替え順序を可能にします。  
* [インデックス エンティティのパターン](#index-entities-pattern) -をエンティティ一覧を返す、効率的な検索を有効にするインデックスのエンティティを管理します。  

### <a name="sorting-data-in-the-table-service"></a>Table service でデータを並べ替える
Table service は、**PartitionKey** 次に **RowKey** に基づいた昇順で並べ替え、エンティティを返します。 これらのキーは文字列値であり、数値を正しく並べ替えるには、固定長の値に変換し、ゼロ パディングを施す必要があります。 たとえば、従業員 ID 値を整数値の **RowKey** として使用する場合、従業員 ID を **123** から **00000123** に変換する必要があります。  

さまざまな順序 (名前、入社日など) で並べ替えられたデータを使う必要のあるアプリケーションは多数あります。 セクションの次のパターンでは、 [テーブルの設計パターン](#table-design-patterns) エンティティの並べ替え順序を代替する方法について説明します。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) -異なる RowKey 値(同じパーティション) を使用して各エンティティの複数のコピーを格納し、異なる RowKey 値を使用して効果的な検索と代替的な並べ替え順序を可能にします。  
* [パーティション内のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) -別個のテーブルの別個のパーティションの異なる RowKey 値を使用して各エンティティの複数のコピーを格納し、異なる RowKey 値を使用して効果的な検索と代替的な並べ替え順序を可能にします。
* [ログ テール パターン](#log-tail-pattern) - 逆の日付と時間順で並べ替える *RowKey* 値を使用して、パーティションに最も新しく追加されたエンティティ **n** を取得します。  

## <a name="design-for-data-modification"></a>データの変更に対応した設計
このセクションでは、挿入、更新、削除の操作を最適化するための設計上の考慮事項を示します。 場合によっては、リレーショナル データベースの設計と同様に、クエリ向けの最適化とデータ変更向けの最適化のトレードオフを評価する必要があります (設計のトレードオフを管理する手法はリレーショナル データベースでは異なります)。 [テーブルの設計パターン](#table-design-patterns) のセクションでは、Table service の詳細な設計パターンをいくつか説明し、これらのトレードオフに注目します。 実際のところ、クエリ向けに最適化された設計の多くは、エントリの変更にも適していることがおわかりになると思います。  

### <a name="optimizing-the-performance-of-insert-update-and-delete-operations"></a>挿入、更新、削除の操作のパフォーマンスを最適化する
エンティティを更新または削除するには、**PartitionKey** と **RowKey** 値を使用してエンティティを識別する必要があります。 この点で、エンティティの変更のために選択した **PartitionKey** と **RowKey** は、できるだけ効率的にエンティティを識別するため、ポイント クエリをサポートするために選択したものと同様の条件に従う必要があります。 **PartitionKey** と **RowKey** 値の検出のためにエンティティを特定する非効率的なパーティションまたはテーブル スキャンを使用したくない場合は、更新または削除する必要があります。  

セクションの次のパターン [Table 設計パターン](#table-design-patterns) では、パフォーマンスの最適化または操作の挿入、更新、削除について説明します。  

* [頻度の高いパターンを削除する](#high-volume-delete-pattern) -独自の個別のテーブルで同時に削除のすべてのエンティティを格納することにより、大量のエンティティの削除を有効にするには、テーブルを削除して、エンティティを削除します。  
* [データ系列のパターン](#data-series-pattern) -単一のエンティティで完全なデータ系列を格納し、リクエストの作成を最小限に抑えます。  
* [ワイド エンティティ パターン](#wide-entities-pattern) -複数の物理エンティティを使用し、252 個以上のプロパティを持つ論理エンティティを格納します。  
* [大型エンティティ パターン](#large-entities-pattern) -大規模なプロパティの値を格納する BLOB ストレージの使用します。  

### <a name="ensuring-consistency-in-your-stored-entities"></a>格納されたエンティティの一貫性を確保する
データの変更を最適化するためのキーの選択を左右する要因として、アトミックなトランザクションを使って一貫性を確保する方法も挙げられます。 同じパーティションに格納されたエンティティを操作する場合は、EGT を使用します。  

セクションの次のパターン [テーブルの設計パターン](#table-design-patterns) では、 一貫性の管理を説明します。  

* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern) -異なる **RowKey** 値 (同じパーティション) を使用して各エンティティの複数のコピーを格納し、異なる **RowKey** 値を使用して効果的な検索と代替的な並べ替え順序を可能にします。  
* [パーティション内のセカンダリ インデックス パターン](#inter-partition-secondary-index-pattern) - 異なる別個のテーブルの別個のパーティションの RowKey 値を使用して複数のコピーを格納し、高速で効率的な参照とを使用して、 異なる **RowKey** 値による代替の並べ替え順序を可能にします。  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) -Azure キューを使用してパーティションの境界または記憶域システムの境界にまたがる一貫した動作を最終的に有効にします。
* [インデックス エンティティのパターン](#index-entities-pattern) -をエンティティ一覧を返す、効率的な検索を有効にするインデックスのエンティティを管理します。  
* [非正規化パターン](#denormalization-pattern) -関連するデータを単一のエンティティに結合し、必要なすべてのデータを1 つのポイント クエリで取得することを可能にします。  
* [データ系列のパターン](#data-series-pattern) -単一のエンティティで完全なデータ系列を格納し、リクエストの作成を最小限に抑えます。  

エンティティ グループ トランザクションの詳細については、「 [エンティティ グループ トランザクション](#entity-group-transactions)」のセクションを参照してください。  

### <a name="ensuring-your-design-for-efficient-modifications-facilitates-efficient-queries"></a>効率的な変更に対応した設計によるクエリの効率化
効率的なクエリに適した設計は変更の効率も高いのが普通ですが、自分のシナリオにもそれが当てはまるかどうかは必ず評価する必要があります。 [テーブルの設計パターン](#table-design-patterns)セクションのパターンの中には、エンティティをクエリして変更する間に明示的にトレードオフを評価するものがあります。常に各操作数を考慮しておく必要があります。  

[テーブルの設計パターン](#table-design-patterns) セクションの以下のパターンでは、 効率的なクエリの設計と効率的なデータ変更の設計の間のトレードオフについて説明します。  

* [複合キー パターン](#compound-key-pattern) - 複合 **RowKey** 値を使用して、1 つのポイント クエリに関連するデータをクライアントが検索できるようにします。  
* [ログ テール パターン](#log-tail-pattern) - 逆の日付と時間順で並べ替える *RowKey* 値を使用して、パーティションに最も新しく追加されたエンティティ **n** を取得します。  

## <a name="encrypting-table-data"></a>テーブル データの暗号化
.NET Azure Storage クライアント ライブラリでは、挿入および置換操作の文字列エンティティ プロパティの暗号化がサポートされます。 暗号化された文字列はバイナリ プロパティとしてサービスで保存され、復号化された後、文字列に変換されて戻されます。    

テーブルの場合、暗号化ポリシーに加え、ユーザーは暗号化するプロパティを指定する必要があります。 これを実行するには、[EncryptProperty] 属性を指定するか (TableEntity から派生した POCO エンティティ用)、または要求オプションで暗号化リゾルバーを指定します。 暗号化リゾルバーは、パーティション キー、行キー、プロパティ名を取得するデリゲートで、プロパティを暗号化するかどうかを示すブール値を返します。 暗号化時、クライアント ライブラリはこの情報を使用して、ネットワークへの書き込み時にプロパティを暗号化するかどうかを決定します。 また、デリゲートは、プロパティの暗号化方法に関するロジックを使用する可能性にも備えます。 (X の場合、プロパティ A を暗号化し、それ以外の場合はプロパティ A および B を暗号化するなど。)エンティティの読み込み中、またはクエリの実行中は、この情報を指定する必要はありません。

現在、マージはサポートされていません。 別のキーを使用してプロパティのサブセットが以前に暗号化されている場合、新しいプロパティをマージしたり、メタデータを更新したりするとデータ損失が発生します。 マージでは、追加のサービス呼び出しをして既存のエンティティをサービスから読み込むか、プロパティごとに新しいキーを使用する必要があります。いずれの方法も、パフォーマンス上の理由でお勧めできません。     

テーブル データの暗号化については、「 [Microsoft Azure Storage のクライアント側の暗号化と Azure Key Vault](../storage/common/storage-client-side-encryption.md)」を参照してください。  

## <a name="modeling-relationships"></a>リレーションシップのモデル化
複雑なシステムの設計において、ドメイン モデルの作成は重要なステップです。 通常は、ビジネス ドメインについて理解し、システムの設計を伝えるための方法として、モデル化プロセスを使用してエンティティとエンティティどうしのリレーションシップを特定します。 このセクションでは、ドメイン モデル内の一般的なリレーションシップの種類を Table service 向けの設計に変換する方法を中心に説明します。 論理データ モデルから物理的な NoSQL ベースのデータ モデルへのマッピング プロセスは、リレーショナル データベースの設計時に使われるプロセスとは異なります。 リレーショナル データベースの設計は、通常、冗長性を最小限に抑えるために最適化されたデータの正規化プロセスと、データベースの動作の実装方法を抽象化する宣言によるクエリ機能があることを前提としています。  

### <a name="one-to-many-relationships"></a>一対多のリレーションシップ
ビジネス ドメイン オブジェクトの間で一対多のリレーションシップが存在することはよくあります。たとえば、1 つの部署に多数の従業員が存在する場合などです。 特定のシナリオにおいて、長短それぞれあるものの、Table service に一対多のリレーションシップを実装する方法はいくつかあります。  

何万もの部署と従業員のエンティティがある大規模な多国籍企業の例を考えてみてください。各部署には多数の従業員が在籍しており、各従業員は 1 つの特定の部署に関連付けられています。 次のように、部署のエンティティと従業員のエンティティを分けて格納する方法もあります。  

![][1]

この例は、 **PartitionKey** 値に基づいて、各種類における暗黙の一対多のリレーションシップを示しています。 各部署に多数の従業員が存在する可能性があります。  

この例は、部署エンティティと、同じパーティションに含まれる関連の従業員エンティティも示しています。 別のエンティティの種類として、別のパーティション、テーブル、またはストレージ アカウントを使うこともできます。  

別の方法として、次の例に示すように、データを非正規化し、非正規化された部署データと共に従業員エンティティのみを格納する方法もあります。 このシナリオで部署のマネージャーの詳細を変更できるようにする必要がある場合は、この非正規化の方法は最適ではない可能性があります。部署内のすべての従業員を更新する必要が生じるためです。  

![][2]

詳細については、 このガイドで後述する [非正規化パターン](#denormalization-pattern) を参照してください。  

次の表に、上記で概要を示した一対多のリレーションシップを持つ従業員エンティティと部署エンティティを格納するアプローチについて、それぞれの長所と短所をまとめます。 また、各種操作をどの程度の頻度で実行する見込みかも検討する必要があります。コストの高い操作であっても、実行頻度が高くなければ設計に含めてもかまいません。  

<table>
<tr>
<th>アプローチ</th>
<th>長所</th>
<th>短所</th>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブルは同じ</td>
<td>
<ul>
<li>1 回の操作で部署エンティティを更新できる。</li>
<li>従業員エンティティを更新、挿入、削除するたびに部署エンティティを変更する必要がある場合は、一貫性を維持するために EGT を使用できます。 たとえば、部署ごとの従業員数を管理する場合などです。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>ストレージ操作が同じパーティションで行われる。 トランザクションの量が多いときにホットスポットが生じる可能性がある。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>エンティティの種類は別、パーティション、テーブル、ストレージ アカウントは別</td>
<td>
<ul>
<li>1 回の操作で部署エンティティと従業員エンティティを更新できる。</li>
<li>トランザクションの量が多いときに、負荷をより多くのパーティションに分散させることができる。</li>
</ul>
</td>
<td>
<ul>
<li>場合によっては、一部のクライアント アクティビティで、従業員エンティティと部署エンティティの両方を取得する必要がある。</li>
<li>従業員を更新、挿入、削除し、部署を更新するときに、一貫性を維持するために EGT を使用できる。 たとえば、部署エンティティ内の従業員数を更新する場合などです。</li>
<li>EGT を使用して従業員を新しい部署に移動できない。</li>
</ul>
</td>
</tr>
<tr>
<td>単一のエンティティの種類への非正規化</td>
<td>
<ul>
<li>必要なすべての情報を 1 回の要求で取得できる。</li>
</ul>
</td>
<td>
<ul>
<li>部署の情報を更新する必要がある場合、一貫性の維持のコストが高くなる可能性がある (部署のすべての従業員を更新する必要があるため)。</li>
</ul>
</td>
</tr>
</table>

これらの選択肢のうちのどれを選ぶかや、どの長所と短所の影響が最も大きいかは、アプリケーションのシナリオによって異なります。 たとえば、部署エンティティを変更する頻度、すべての従業員クエリに追加の部署情報が必要かどうか、パーティションまたはストレージ アカウントのスケーラビリティの制限までどのくらいかなどです。  

### <a name="one-to-one-relationships"></a>一対一のリレーションシップ
ドメイン モデルにはエンティティ間の一対一のリレーションシップが含まれることもあります。 Table service で一対一のリレーションシップを実装する必要がある場合は、2 つの関連するエンティティを取得する必要があるときにそれらをリンクする方法も選択する必要があります。 このリンクはキー値の規則に基づいて、各エンティティにおいて **PartitionKey** と **RowKey** 値形式で関連エンティティへのリンクを格納することで、明示的にも暗黙的にも成り得ます。 同じパーティションに関連エンティティを格納するかどうかの詳細については、 [一対多のリレーションシップ](#one-to-many-relationships)セクションを参照してください。  

実装上の検討内容に応じて、Table service で一対一のリレーションシップを実装する必要が生じることもあります。  

* ラージ エンティティを処理する (詳細については、「 [ラージ エンティティ パターン](#large-entities-pattern)」を参照してください)。  
* アクセス制御を実装する (詳細については、 [共有アクセス署名でのアクセスを制御する](#controlling-access-with-shared-access-signatures)参照してください)。  

### <a name="join-in-the-client"></a>クライアントでの結合
Table service でのリレーションシップのモデル化には何とおりかの方法があるものの、Table service を使う主な理由はスケーラビリティとパフォーマンスの 2 つであることを忘れないでください。 ソリューションのパフォーマンスとスケーラビリティを損なう多数のリレーションシップをモデル化しようとしていることに気が付いた場合は、そのすべてのデータ リレーションシップをテーブル設計に組み込む必要があるかどうかを確認する必要があります。 クライアント アプリケーションで必要な結合が実行されるようにすると、設計を簡素化し、ソリューションのスケーラビリティとパフォーマンスを向上させることができます。  

たとえば、変更頻度の高くないデータが格納された小さなテーブルがある場合は、そのデータを取得した後でクライアント上にキャッシュできます。 そうすると、何度も同じデータを取得する必要がなくなります。 このガイドで見てきた例では、小規模な組織の部署のセットは小さく、変更頻度も低いことが多いので、データをクライアント アプリケーションでダウンロードしてからルックアップ データとしてキャッシュするのに適しています。  

### <a name="inheritance-relationships"></a>継承リレーションシップ
クライアント アプリケーションでビジネス エンティティを表す継承リレーションシップの一部を構成するクラスのセットを使用する場合は、それらのエンティティを Table service で簡単に保持できます。 たとえば、 **人** が抽象クラスとなっているクライアント アプリケーションにはクラスセットが定義されている可能性があります。

![][3]

エンティティを次のように扱う 1 つの Person テーブルを使えば、2 つの具象クラスのインスタンスを Table service で維持できます。  

![][4]

クライアント コードの同じテーブル内の複数のエンティティ種類の詳細については、このガイドの後述のセクション [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types) を参照してください。 クライアント コードでエンティティの種類を認識する方法の例が示されています。  

## <a name="table-design-patterns"></a>テーブルの設計パターン
前のセクションでは、クエリを使用してエンティティ データを取得する場合と、エンティティ データを挿入、更新、削除する場合の両方のテーブル設計を最適化する方法について詳しく説明しました。 このセクションでは、Table service ソリューションで使用するのに適したパターンをいくつか紹介します。 また、このガイドで前に提起された問題とトレードオフの一部に実際に対処する方法を説明しています。 次の図は、さまざまなパターンの関係をまとめたものです。  

![][5]

上記のパターン マップには、このガイドに記載されているパターン (青) とアンチパターン (オレンジ) の関係の一部が示されています。 もちろん、検討する価値があるパターンは他にもたくさんあります。 たとえば、Table サービス向けの主なシナリオの 1 つに、[コマンド クエリ責務分離 (CQRS) パターン](https://msdn.microsoft.com/library/azure/jj554200.aspx)からの[具体化されたビュー パターン](https://msdn.microsoft.com/library/azure/dn589782.aspx)の使用があります。  

### <a name="intra-partition-secondary-index-pattern"></a>パーティション内のセカンダリ インデックス パターン
異なる **RowKey** 値 (同じパーティション内) を使用して各エンティティの複数のコピーを格納し、異なる **RowKey** 値を使用した高速で効率的な検証と代替の並べ替え順序を可能にします。 コピー間の更新の一貫性は、EGT を使用して保つことができます。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table service は **PartitionKey** と **RowKey** 値を使用して自動的にインデックスを作成します。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用することにより、クライアント アプリケーションでは、ポイント クエリを使用して部署名と従業員 ID (**PartitionKey** と **RowKey** 値) から、個々の従業員エンティティを取得できます。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。

![][6]

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。 さらに、 **RowKey** 順以外の順序で並べ替えられた従業員の一覧を要求するオプションはありません。  

#### <a name="solution"></a>解決策
セカンダリ インデックスの不足を回避するには、異なる **RowKey** 値を使用して各コピーの複数コピーを格納します 。 次のような構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。**RowKey** のプレフィックス値、"empid"、"email" で、1 人の従業員をクエリするか電子メール アドレスまたは従業員 ID の範囲を使用して、ある特定の範囲の従業員をクエリできます。  

![][7]

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

* $filter = (PartitionKey eq 'Sales') と (RowKey eq 'empid_000223')  
* $filter=(PartitionKey eq 'Sales') と (RowKey eq 'email_jonesj@contoso.com')  

一連の複数の従業員エンティティの範囲をクエリする場合は、従業員 ID の順に並べ替えられた範囲を指定するか、適切なプレフィックスを持つエンティティのクエリを実行して、 **RowKey**で電子メール アドレスの順序で格納されている範囲を指定できます。  

* Sales 部署において、従業員 ID、000100 から 000199 を指定して、すべての従業員を検索するには: $filter=(PartitionKey eq 'Sales') and (RowKey ge 'empid_000100') and (RowKey le 'empid_000199') を使用します。  
* Sales 部署において、'a' で始まる電子メール アドレスを持つすべての従業員を検索するには:$filter=(PartitionKey eq 'Sales') and (RowKey ge 'email_a') and (RowKey lt 'email_b') を使用します。  
  
  上記の例で使用しているフィルター構文は、Table service REST API の構文です。詳細については、「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」(エンティティの照会) を参照してください。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
* セカンダリ インデックス エンティティは元のエンティティと同じパーティションに格納されるため、個々のパーティションのスケーラビリティ ターゲットを超えないようにする必要があります。  
* EGT を使用してエンティティの 2 つのコピーをアトミックに更新することで、重複するエンティティどうしの一貫性を保つことができます。 そのためには、エンティティのすべてのコピーを同じパーティションに格納する必要があります。 詳細については、 [エンティティ グループ トランザクションを使用する](#entity-group-transactions)セクションを参照してください。  
* **RowKey** に使用される値は 各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
* 数値を **RowKey** (たとえば、従業員 ID 000223)にパディングすると、上限と下限に基づき正確な並べ替えとフィルタリングが可能になります。  
* 必ずしもエンティティのすべてのプロパティを複製する必要はありません。 たとえば、電子メールアドレスを使用してエンティティを **RowKey** で検索するクエリの場合、従業員の年齢は不要です。このようなエンティティは、次のような構造になっている可能性があります。

![][8]

* 通常は、エンティティの検索と必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。 ただし、異なる **RowKey** 値を使用してエンティティ参照を実行している場合は、パーティションのスケーラビリティの制限を超えていないことを確認してください。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [パーティション内セカンダリ インデックス パターン](#inter-partition-secondary-index-pattern)
* [複合キー パターン](#compound-key-pattern)
* [エンティティ グループ トランザクション](#entity-group-transactions)
* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)

### <a name="inter-partition-secondary-index-pattern"></a>パーティション内のセカンダリ インデックス パターン
別個のテーブルの別個のパーティションの異なる**RowKey** 値 (同じパーティション内) を使用して各エンティティの複数のコピーを格納し、異なる **RowKey** 値を使用した高速で効率的な検証と代替の並べ替え順序を可能にします。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table service は **PartitionKey** と **RowKey** 値を使用して自動的にインデックスを作成します。 そのため、クライアント アプリケーションでは、これらの値を使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用することにより、クライアント アプリケーションでは、ポイント クエリを使用して部署名と従業員 ID (**PartitionKey** と **RowKey** 値) から、個々の従業員エンティティを取得できます。 また、各部署内の従業員 ID で並べ替えたエンティティを取得することも可能です。  

![][9]

また、電子メール アドレスなど、他のプロパティの値に基づいて従業員エンティティを検索できるようにする場合は、効率の劣るパーティション スキャンを使用して、一致するエンティティを検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。 さらに、 **RowKey** 順以外の順序で並べ替えられた従業員の一覧を要求するオプションはありません。  

これらのエンティティに対するトランザクションの量が膨大になることが予想される場合は、Table service によってクライアントがレート制限されるリスクを最小限に抑える必要があります。  

#### <a name="solution"></a>解決策
セカンダリ インデックスの不足を回避するには、異なる**PartitionKey** と **RowKey** 値を使用して各コピーの複数コピーを格納します。 次のような構造体を持つエンティティを格納する場合は、電子メール アドレスや従業員 ID に基づく複数の 従業員エンティティを効率的に取得できます。**PartitionKey** のプレフィックスの値、"empid_" と "email_" で、クエリに使用するインデックスを特定することができます。  

![][10]

次の 2 つのフィルター条件 (従業員 ID で検索するフィルター条件と電子メール アドレスで検索するフィルター条件) ではどちらもポイント クエリを指定しています。  

* $filter=(PartitionKey eq 'empid_Sales') and (RowKey eq '000223')
* $filter=(PartitionKey eq 'email_Sales') と (RowKey eq 'jonesj@contoso.com')  

一連の複数の従業員エンティティの範囲をクエリする場合は、従業員 ID の順に並べ替えられた範囲を指定するか、適切なプレフィックスを持つエンティティのクエリを実行して、 **RowKey**で電子メール アドレスの順序で格納されている範囲を指定できます。  

* 従業員 ID 順で格納された、従業員 ID が**000100** から **000199** の範囲の Sales 部署のすべての従業員を検索するには、$filter=(PartitionKey eq 'empid_Sales') と (RowKey ge '000100') および (RowKey le '000199') を使用します。  
* Sales 部署において、電子メール アドレス順で格納された電子メール アドレスで、'a' で始まる電子メール アドレスを持つすべての従業員を検索するには: $filter=(PartitionKey eq 'email_Sales') and (RowKey ge 'a') and (RowKey lt 'b') を使用します。  

上記の例で使用しているフィルター構文は、Table service REST API の構文です。詳細については、「[Query Entities](http://msdn.microsoft.com/library/azure/dd179421.aspx)」(エンティティの照会) を参照してください。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* プライマリとセカンダリ インデックスのエンティティを維持するため、重複するエンティティを保持して、 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) を使用し、互いに最終的に一貫性を持たせます。  
* テーブル ストレージは比較的低コストで利用できるため、重複するデータを格納してもコストは大きな問題になりません。 ただし、必ず、予想されるストレージ要件に基づいて設計のコストを見積もり、クライアント アプリケーションが実行するクエリで使用するエンティティのみを複製する必要があります。  
* **RowKey** に使用される値は 各エンティティに対して一意である必要があります。 複合キー値の使用を検討してください。  
* 数値を **RowKey** (たとえば、従業員 ID 000223)にパディングすると、上限と下限に基づき正確な並べ替えとフィルタリングが可能になります。  
* 必ずしもエンティティのすべてのプロパティを複製する必要はありません。 たとえば、電子メールアドレスを使用してエンティティを **RowKey** で検索するクエリの場合、従業員の年齢は不要です。このようなエンティティは、次のような構造になっている可能性があります。
  
  ![][11]
* 通常は、セカンダリ インデックスを使用したエンティティの検索とプライマリ インデックス内の必要なデータの検索にそれぞれ異なるクエリを使用するよりも、重複するデータを格納し、必要なすべてのデータを単一のクエリで取得できるようにすることをお勧めします。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
クライアント アプリケーションで異なるさまざまなキーを使用してエンティティを取得する必要がある場合、クライアントで異なる順序で並べ替えたエンティティを取得する必要がある場合、さまざまな一意の値を使用して各エンティティを識別できる場合に、このパターンを使用します。 異なる **RowKey** 値を使用して、エンティティ参照を実行しているおり、パーティションのスケーラビリティの制限を超えないようにしたい場合、このパターンを使用します 。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [パーティション内のセカンダリ インデックス パターン](#intra-partition-secondary-index-pattern)  
* [複合キー パターン](#compound-key-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)  

### <a name="eventually-consistent-transactions-pattern"></a>最終的に一貫性のあるトランザクション パターン
Azure キューを使用して、パーティションやストレージ システムの境界を越えて、最終的に一貫した動作を実現します。  

#### <a name="context-and-problem"></a>コンテキストと問題
EGT を使用すると、同じパーティション キーを共有する複数のエンティティに対してアトミックなトランザクションを実行できます。 パフォーマンスやスケーラビリティの関係で、一貫性が必要なエンティティを別々のパーティションや別のストレージ システムに格納する場合があります。そのような場合は、EGT を使用して一貫性を保つことはできません。 たとえば、次の一貫性を最終的に確保する必要があるとします。  

* 同じテーブル内の 2 つの異なるパーティション、異なるテーブル、異なるストレージ アカウントに格納されているエンティティ。  
* Table service に格納されているエンティティと Blob service に格納されている BLOB。  
* Table service に格納されているエンティティとファイル システム内のファイル。  
* Table service に格納されているにもかかわらず、Azure Search サービスを使用してインデックスが作成されているエンティティ。  

#### <a name="solution"></a>解決策
Azure キューを使用すると、2 つ以上のパーティションまたはストレージ システム間で最終的に一貫性を確保するソリューションを実装できます。
この方法を説明するために、退職した従業員エンティティをアーカイブできるようにする必要があるとします。 退職した従業員エンティティはめったに照会されず、現在の従業員を対象にしたすべてのアクティビティから除外する必要があります。 この要件を実装するには、**現在**テーブルにいる現在の従業員と、**アーカイブ** テーブルにいる退職した従業員を格納します。 従業員をアーカイブするには、**現在**テーブルからのエンティティを削除し、**アーカイブ** テーブルにエンティティを追加する必要がありますが、これら 2 つの操作を実行する EGT は使用できません。 エンティティが両方のテーブルに表示されることや、どちらのテーブルにも表示されないことがないように、アーカイブ操作は最終的に一貫性が確保される必要があります。 次のシーケンス図は、この操作の大まかな手順を示しています。 その下のテキストには、例外パスの詳細が示されています。  

![][12]

クライアントは、Azure キューにメッセージを配置することによって、アーカイブ操作を開始します。この例では、ID が 456 の従業員をアーカイブします。 worker ロールは、キューをポーリングして新しいメッセージの有無を確認します。メッセージを見つけると、そのメッセージを読み取り、隠しコピーをキューに残します。 worker ロールは、次に、**現在**テーブルからコピーをフェッチし、**アーカイブ** テーブルにコピーを挿入し、その後、元のデータを**現在**テーブルから削除します。 最後に、前の手順でエラーが発生しなければ、worker ロールはキューから隠しメッセージを削除します。  

この例では、ステップ 4 で従業員を **アーカイブ** テーブルに挿入しています。 Blob service の BLOB またはファイル システム内のファイルに従業員を加えることもできます。  

#### <a name="recovering-from-failures"></a>エラーからの回復
worker ロールがアーカイブ操作を再開する必要がある場合、手順 **4** と **5** の操作が*べき等*になっていることが重要です。 Table service を使用している場合、手順 **4** で「挿入または置換」操作を使用する必要があります。手順 **5** では、使用しているクライアント ライブラリ で "存在する場合は削除" 操作を使用する必要があります。 他のストレージ システムを使用する場合は、適切なべき等操作を使用する必要があります。  

worker ロールが手順 **6**を完了しない場合は、タイムアウトの後、メッセージが worker ロール準備完了のキューに表示され再処理を試みます。 worker ロールは、キュー上のメッセージを読み取った回数を確認し、必要に応じて、別のキューに送信することで、調査のために "有害" メッセージとしてフラグを設定できます。 キュー メッセージの読み取りとデキューカウントのチェックに関する詳細については、 [メッセージを取得](https://msdn.microsoft.com/library/azure/dd179474.aspx)を参照してください。  

Table サービスと Queue サービスのエラーには一時的なエラーもあります。クライアント アプリケーションには、そうしたエラーに対処する適切な再試行ロジックを組み込む必要があります。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* このソリューションは、トランザクションを分離するためのソリューションではありません。 たとえば、worker ロールがステップ **4** と **5** の間で、クライアントは**現在**と**アーカイブ** テーブルを読み込むことができます。また、データの非一貫性表示を参照できます。 データは最終的に一貫性が確保されます。  
* 最終的に一貫性を確保するために、手順 4. と 5. がべき等になっていることを確認する必要があります。  
* 複数のキューと worker ロール インスタンスを使用して、ソリューションを拡張できます。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
別のパーティションまたはテーブルに存在するエンティティ間の一貫性を最終的に確保する必要がある場合に、このパターンを使用します。 このパターンを拡張して、Table service と Blob service のほかにも、データベースやファイル システムなどの Azure 以外のストレージ データ ソース間の操作で最終的な一貫性を確保できます。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [マージまたは置換](#merge-or-replace)  

> [!NOTE]
> ソリューションにとってトランザクションの分離が重要な場合は、EGT を使用できるようにテーブルを再設計することを検討する必要があります。  
> 
> 

### <a name="index-entities-pattern"></a>インデックス エンティティのパターン
インデックス エンティティを保持して、エンティティの一覧を返す効率の良い検索を実現します。  

#### <a name="context-and-problem"></a>コンテキストと問題
Table service は **PartitionKey** と **RowKey** 値を使用して自動的にインデックスを作成します。 そうすると、クライアント アプリケーションでポイント クエリを使用してエンティティを効率的に取得できます。 たとえば、次のようなテーブル構造を使用することにより、クライアント アプリケーションでは、部署名と従業員 ID (**PartitionKey** と **RowKey** 値) から、個々の従業員エンティティを効率的に取得できます。  

![][13]

また、姓など、一意ではない他のプロパティの値に基づいて従業員エンティティの一覧を取得できるようにする場合は、インデックスを使用して直接一致するエンティティを検索せずに、効率の劣るパーティション スキャンを使用して検索する必要があります。 これは、Table サービスではセカンダリ インデックスが提供されないためです。  

#### <a name="solution"></a>解決策
上のエンティティ構造の場合、姓で検索できるようにするには、従業員 ID の一覧を保持する必要があります。 Jones など、特定の姓を持つ従業員エンティティを取得するには、まず姓が Jones である従業員の従業員 ID の一覧を検索してから、それらの従業員エンティティを取得する必要があります。 従業員 ID の一覧を格納する方法は主に次の 3 つがあります。  

* BLOB ストレージを使用する。  
* 従業員エンティティと同じパーティションにインデックス エンティティを作成する。  
* 別のパーティションまたはテーブルにインデックス エンティティを作成する。  

<u>オプション 1: BLOB ストレージの使用</u>  

最初のオプションでは、すべての一意の姓について Blob を作成し、その姓の従業員用の各 Blob には **PartitionKey** (部署) と **RowKey** (従業員 ID) 値が格納されます。 従業員を追加または削除した場合は、関連する BLOB の内容と従業員エンティティの一貫性が最終的に確保されていることを確認する必要があります。  

<u>オプション 2:</u> 同じパーティション内のインデックス エンティティの作成  

2 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][14]

**従業員 ID** プロパティには、**RowKey** に格納されている姓を持つ従業員の従業員 ID リストが含まれています。  

次の手順は、2 番目の方法を使用した場合に、新しい従業員を追加するときに従う必要がある手順の概要を示しています。 この例では、Sales 部署で ID が 000152、姓が Jones の従業員を追加します。  

1. **PartitionKey** 値 "Sales" と **RowKey** 値 "Jones"　を持つインデックスのエンティティを取得します。 このエンティティの ETag を、手順 2. で使用するために保存します。  
2. 新しい従業員エンティティを挿入するエンティティ グループ トランザクション、つまり、バッチ操作(**PartitionKey** 値 "Sales" と **RowKey** 値 "000152") を作成し、新しい従業員 ID を従業員 ID フィールドに追加することでインデックス エンティティ (**PartitionKey** 値 "Sales" と **RowKey** 値 "Jones") を更新します。 エンティティ グループ トランザクションの詳細については、「 [エンティティ グループ トランザクション](#entity-group-transactions)」をご覧ください。  
3. オプティミスティック同時実行エラー (他のユーザーがインデックス エンティティを変更したこと) が原因でエンティティ グループ トランザクションが失敗した場合は、手順 1 からまたやり直す必要があります。  

2 番目の方法を使用する場合は、同じような方法で従業員を削除できます。 従業員の姓を変更するのは、3 つのエンティティ (従業員エンティティ、元の姓のインデックス エンティティ、新しい姓のインデックス エンティティ) を更新するエンティティ グループ トランザクションを実行する必要があるため、少し複雑です。 変更を加える前に、各エンティティを取得して、ETag 値を取得する必要があります。その ETag 値を使用して、オプティミスティック同時実行で更新を実行できます。  

次の手順は、2 番目の方法を使用した場合に、ある部署で特定の姓を持つすべての従業員を検索する必要があるときに従う必要がある手順の概要を示しています。 この例では、Sales 部署で姓が Jones のすべての従業員を検索します。  

1. **PartitionKey** 値 "Sales" と **RowKey** 値 "Jones"　を持つインデックスのエンティティを取得します。  
2. EmployeeIDs フィールドで従業員 ID の一覧を解析します。  
3. 各従業員に関する追加情報(電子メール アドレスなど) が必要な場合は、手順 2 で取得した従業員リストから **PartitionKey** 値 "Sales" と **RowKey** 値を使用して各従業員のエンティティを取得します。  

<u>オプション 3:</u> 別のパーティションまたはテーブルにインデックス エンティティを作成する  

3 番目の方法では、以下のデータを格納するインデックス エンティティを使用します。  

![][15]

**従業員 ID** プロパティには、**RowKey** に格納されている姓を持つ従業員の従業員 ID リストが含まれています。  

3 番目の方法では、インデックス エンティティが従業員エンティティとは別のパーティションにあるため、EGT を使用して一貫性を保つことはできません。 インデックス エンティティが従業員エンティティと最終的に一貫していることを確認する必要があります。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* このソリューションでは、一致するエンティティを取得するために、少なくとも 2 つのクエリが必要です。1 つはインデックス エンティティを照会して **RowKey** 値の一覧を取得するクエリです。もう 1 つはその一覧内の各エンティティを取得するクエリです。  
* 個々のエンティティの最大サイズは 1 MB であるため、ソリューションの方法 2 と方法 3 では、特定の姓の従業員 ID の一覧が 1 MB を超えることがないと仮定しています。 従業員 ID の一覧のサイズが 1 MB を超える可能性がある場合は、方法 1 を使用して、BLOB ストレージにインデックス データを格納します。  
* 方法 2 を使用する (EGT を使用して、従業員の追加と削除、従業員の姓の変更を処理する) 場合は、トランザクションの量が特定のパーティションのスケーラビリティの限界に近づくかどうかを確認する必要があります。 限界に近づく場合は、キューを使用して更新要求を処理し、従業員エンティティとは別のパーティションにインデックス エンティティを格納でき、最終的に一貫性が確保されるソリューション (方法 1 または方法 3) を検討する必要があります。  
* このソリューションの方法 2 では、部署内を姓で検索する (たとえば、Sales 部署で姓が Jones の従業員の一覧を取得する) 必要があると想定しています。 組織全体で姓が Jones のすべての従業員を検索できる必要がある場合は、方法 1 と方法 3 のどちらかを使用します。
* 最終的に一貫性が確保されるキューベースのソリューションを実装できます (詳細については、「 [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) 」を参照してください)。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
姓が Jones のすべての従業員など、特定のプロパティ値がすべて共通している一連のエンティティを検索する場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)  

### <a name="denormalization-pattern"></a>非正規化パターン
関連するデータを 1 つのエンティティに結合し、1 回のポイント クエリで必要なデータをすべて取得できるようにします。  

#### <a name="context-and-problem"></a>コンテキストと問題
リレーショナル データベースでは、通常、重複を排除するためにデータを正規化します。その結果、クエリで複数のテーブルからデータを取得することになります。 Azure テーブルのデータを正規化した場合、関連するデータを取得するには、クライアント アプリケーションとサーバー間のラウンド トリップを複数回行う必要があります。 たとえば、以下のテーブル構造を使用した場合、部署の詳細を取得するためには、2 回ラウンド トリップを行う必要があります。1 回目のラウンド トリップでマネージャーの ID を含む部署エンティティをフェッチし、2 回目に従業員エンティティからマネージャーの詳細をフェッチします。  

![][16]

#### <a name="solution"></a>解決策
データを 2 つのエンティティに格納する代わりに、データを非正規化し、部署エンティティにマネージャーの詳細のコピーを保持します。 例:   

![][17]

格納されている部署エンティティにはこれらのプロパティがあるため、ポイント クエリを使用して、部署に関する必要なすべての詳細を取得できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 一部のデータを重複して格納するため、多少コストがかかります。 通常、ストレージ コストの増加はわずかなため、(ストレージ サービスへの要求が減少することによる) パフォーマンス上のメリットが勝ります (このコストの一部は、部署の詳細をフェッチするために必要なトランザクションの数が減少することで相殺されます)。  
* マネージャーに関する情報を格納する 2 つのエンティティの一貫性を維持する必要があります。 一貫性の問題は、EGT を使用して単一のアトミックなトランザクションで複数のエンティティを更新することで対処できます。この例では、部署エンティティと、部署マネージャーの従業員エンティティが同じパーティションに格納されています。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
関連情報を頻繁に検索する必要がある場合に、このパターンを使用します。 このパターンを使用すると、クライアントが必要なデータを取得するために実行する必要があるクエリの数が減少します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)

### <a name="compound-key-pattern"></a>複合キー パターン
複合 **RowKey** 値を使用して 1 つのポイント クエリに関連するデータを検索するクライアントを有効にします。  

#### <a name="context-and-problem"></a>コンテキストと問題
リレーショナル データベースでは、単一のクエリで関連するデータをクライアントに返すために、クエリでよく結合を使用します。 たとえば、従業員 ID を使用して、その従業員の業績と評価データが含まれている関連エンティティの一覧を検索する場合があります。  

次の構造を使用し、Table service に従業員エンティティを格納しているとします。  

![][18]

また、各年度の従業員の評価と業績に関する履歴データを格納し、この情報に年度別でアクセスできる必要もあります。 それには、次の構造でエンティティを格納する別のテーブルを作成するという方法があります。  

![][19]

この方法では、単一の要求でデータを取得できるようにするには、一部の情報 (姓や名など) を新しいエンティティに複製する必要があります。 ただし、EGT を使用しても 2 つのエンティティをアトミックには更新できないため、強力な整合性を保つことはできません。  

#### <a name="solution"></a>解決策
次の構造のエンティティを使用して、元のテーブルに新しい種類のエンティティを格納します。  

![][20]

**RowKey** が従業員 ID と評価データの年度から構成された複合キーとなり、1 つのエンティティに対する 1 つのリクエストで、従業員の業績と評価データを取得できるようになっていることにご注意ください。  

次の例では、Sales 部署の従業員 000123 など、特定の従業員のすべての評価データを取得する方法を示しています。  

$filter=(PartitionKey eq 'Sales')、(RowKey ge 'empid_000123')、(RowKey lt 'empid_000124')&$select=RowKey,Manager Rating,Peer Rating,Comments  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* **000123_2012** のような、**RowKey** 値の解析を容易にする適切な区切り文字を使用する必要があります。  
* また、このエンティティは、同じ従業員の関連データを含む他のエンティティと同じパーティションに格納します。そうすると、EGT を使用して、強い整合性を維持できます。
* このパターンが適切であるかどうかを判断には、データを照会する頻度を考慮する必要があります。  たとえば、評価データにはあまり頻度にアクセスせず、メインの従業員データには頻度にアクセスする場合は、それらのデータを別々のエンティティとして保持する必要があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
頻繁に照会する関連エンティティを 1 つ以上格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)  
* [異種のエンティティ種類の使用](#working-with-heterogeneous-entity-types)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  

### <a name="log-tail-pattern"></a>ログ テール パターン
逆の日付と時間順でソートする *RowKey* 値を 使用して最も最近追加された **n** を取得します。  

#### <a name="context-and-problem"></a>コンテキストと問題
よく、最近作成されたエンティティ (従業員が提出した経費請求を日時の新しいものから 10 件など) を取得できることが必要な場合があります。 Table クエリは **$top** クエリ操作をサポートして、最初の *n* 件のエンティティをセットから返します。セットの最終 n 件のエンティティを返す同等のクエリの操作はありません。  

#### <a name="solution"></a>解決策
自然に最新のエントリを逆の日付と時刻順で並べ替える **RowKey** を使用してエンティティの保存、するため、表の一番上に直近のエントリが表示されます。  

たとえば、従業員が提出した経費請求を日時の新しいものから 10 件取得できるようにする場合は、現在の日時から派生した逆順のティック値を使用できます。 次の c# のコード サンプルは、最新から最古の順で並べ替える **RowKey** 用の適切な「逆タイマー刻み」値を作成する方法の 1 つを示しています。  

`string invertedTicks = string.Format("{0:D19}", DateTime.MaxValue.Ticks - DateTime.UtcNow.Ticks);`  

次のコードを使用すると、日時値に戻すことができます。  

`DateTime dt = new DateTime(DateTime.MaxValue.Ticks - Int64.Parse(invertedTicks));`  

テーブル クエリは次のようになります。  

`https://myaccount.table.core.windows.net/EmployeeExpense(PartitionKey='empid')?$top=10`  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 文字列値が正しく並び替わるように、逆順のティック値の先頭にゼロをパディングする必要があります。  
* パーティション レベルのスケーラビリティ ターゲットに注意する必要があります。 ホット スポット パーティションが発生しないように注意してください。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
日時の逆順でエンティティにアクセスする必要がある場合、または追加日時の新しい順にエンティティにアクセスする必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [先頭または末尾に追加するアンチ パターン](#prepend-append-anti-pattern)  
* [エンティティの取得](#retrieving-entities)  

### <a name="high-volume-delete-pattern"></a>頻度の高いパターンを削除する
すべてのエンティティを同時削除用に独立したテーブルに格納することで、大量のエンティティを削除できるようにします。エンティティを削除するときは、テーブル自体を削除することになります。  

#### <a name="context-and-problem"></a>コンテキストと問題
多くのアプリケーションでは、クライアント アプリケーションで使用する必要がなくなった古いデータや、他の記憶域メディアにアーカイブした古いデータを削除します。 通常は、日付でそうしたデータを特定します。たとえば、60 日以上前のすべてのサインイン要求のレコードを削除する必要があるとします。  

利用可能な設計の 1 つは、 **RowKey** でのサインイン 要求の日付と時刻の使用です。  

![][21]

この方法では、アプリケーションが別のパーティションで各ユーザーのサインイン エンティティを挿入したり削除したりできるため、パーティションのホット スポットを回避できます。 ただし、まず削除するすべてのエンティティを特定するためにテーブル スキャンを実行し、その後、古い各エンティティを削除する必要があるため、エンティティの数が多い場合、この方法ではコストと時間がかかる可能性があります。 複数の削除要求をバッチ処理として EGT にまとめることで、古いエンティティを削除するのに必要なサーバーへのラウンド トリップの回数を減らすことができます。  

#### <a name="solution"></a>解決策
サインイン試行の日付ごとに異なるテーブルを使用します。 上のエンティティの設計を使用すると、エンティティを挿入する際にホットスポットを回避できます。毎日数百や数千もの個々のサインイン エンティティを検索して削除する代わりに、毎日テーブルを 1 つ削除する (単一のストレージ操作) だけで古いエンティティを削除できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 特定のエンティティの検索、他のデータとのリンク、集計情報の生成など、データの他の用途もサポートするように設計していますか。  
* 新しいエンティティを挿入する際にホットスポットを回避するように設計していますか。  
* テーブル名を削除した後に同じテーブル名を再利用する場合に遅延が必要であります。 常に一意のテーブル名を使用することをお勧めします。  
* Table service ではアクセス パターンを学習して、ノード全体にパーティションを分散しますが、最初に新しいテーブルを使用するときは何らかのレート制限が行われます。 新しいテーブルを作成する必要がある頻度を検討する必要があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
同時に削除する必要があるエンティティが大量にある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)
* [エンティティの変更](#modifying-entities)  

### <a name="data-series-pattern"></a>データ系列のパターン
データ系列全体を単一のエンティティに格納し、要求の数を最小限に抑えます。  

#### <a name="context-and-problem"></a>コンテキストと問題
一般的なシナリオとして、通常、アプリケーションで一度にすべて取得する必要があるデータ系列を格納するというものがあります。 たとえば、アプリケーションで 1 時間ごとに各従業員が送信した IM メッセージの数を記録し、後でその情報を使用して、各ユーザーが過去 24 時間以内に送信したメッセージの数をプロットするとします。 設計の 1 つとして、従業員ごとに 24 個のエンティティを格納します。  

![][22]

この設計では、アプリケーションでメッセージのカウント値を更新する必要があるときに、各従業員の更新するエンティティを簡単に検索して更新できます。 ただし、情報を取得して、過去 24 時間の活動のグラフをプロットするためには、24 個のエンティティを取得する必要があります。  

#### <a name="solution"></a>解決策
次のデザインを使用し、各時間のメッセージ数をそれぞれ別のプロパティに格納します。  

![][23]

この設計では、マージ操作を使用して、特定の時間の従業員のメッセージ数を更新できます。 これで、単一のエンティティに対する単一の要求を使用して、チャートをプロットするために必要なすべての情報を取得できます。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* データ系列全体が単一のエンティティに収まらない場合 (エンティティは最大 252 個のプロパティを持つことができます)、BLOB などの代わりのデータ ストアを使用します。  
* 複数のクライアントが同時にエンティティを更新する場合は、 **ETag** を使用して、オプティミスティック同時実行を実装する必要があります。 クライアントがたくさんある場合は、競合が大量に発生する可能性があります。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
個々のエンティティに関連付けられているデータ系列を更新したり取得したりする必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [ラージ エンティティ パターン](#large-entities-pattern)  
* [マージまたは置換](#merge-or-replace)  
* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) (格納するデータ系列を Blob に格納している場合)  

### <a name="wide-entities-pattern"></a>ワイド エンティティ パターン
複数の物理エンティティを使用して、252 を超えるプロパティを持つ論理エンティティを格納します。  

#### <a name="context-and-problem"></a>コンテキストと問題
個々のエンティティが持つことができるプロパティは、(必須のシステム プロパティを除き) 252 個までです。また、格納できるデータは合計で 1 MB までです。 リレーショナル データベースでは、通常、新しいテーブルを追加し、その新しいテーブルと 1 対 1 のリレーションシップを作成することによって、行のサイズに関するさまざまな制限を回避します。  

#### <a name="solution"></a>解決策
Table service を使用すると、複数のエンティティを格納して、252 を超えるプロパティを持つ単一の大きなビジネス オブジェクトを作成できます。 たとえば、過去 365 日の間に各従業員が送信した IM メッセージの数を格納する場合は、スキーマの異なる 2 つのエンティティを使用する次のデザインを使用できます。  

![][24]

両方のエンティティを更新しないとエンティティどうしの同期が維持されない変更を加える必要がある場合は、EGT を使用できます。 それ以外の場合は、単一のマージ操作を使用して、特定の日のメッセージ数を更新できます。 個々 の従業員のすべてのデータを取得するには、**PartitionKey** と **RowKey** 値の両方を使用する 2 つの効率的なリクエストを取得する必要があります。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 論理エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (各物理エンティティを取得するトランザクション) が必要です。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
サイズやプロパティの数が Table service の個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [エンティティ グループ トランザクション](#entity-group-transactions)
* [マージまたは置換](#merge-or-replace)

### <a name="large-entities-pattern"></a>大型エンティティ パターン
BLOB ストレージを使用して、大きなプロパティ値を格納します。  

#### <a name="context-and-problem"></a>コンテキストと問題
個々のエンティティに格納できるデータは合計で 1 MB までです。 1 つまたは複数のプロパティに格納される値でエンティティの合計サイズが 1 MB を超える場合は、Table service にエンティティ全体は格納できません。  

#### <a name="solution"></a>解決策
1 つ以上のプロパティに大量のデータが含まれているためにエンティティのサイズが 1 MB を超える場合は、Blob service にデータを格納し、エンティティのプロパティに BLOB のアドレスを格納できます。 たとえば、従業員の写真を Blob ストレージに格納し、写真へのリンクを従業員エンティティの **フォト** プロパティに格納できます。  

![][25]

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* Table service 内のエンティティと、Blob service 内のデータの間の最終的な一貫性を保つには、[最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern) を使用してエンティティを維持します。
* エンティティ全体を取得するには、少なくとも 2 つのストレージ トランザクション (エンティティを取得するトランザクションと BLOB データを取得するトランザクション) が必要です。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
サイズが Table service の個々のエンティティの制限を超えるエンティティを格納する必要がある場合に、このパターンを使用します。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [最終的に一貫性のあるトランザクション パターン](#eventually-consistent-transactions-pattern)  
* [ワイド エンティティパターン](#wide-entities-pattern)

<a name="prepend-append-anti-pattern"></a>

### <a name="prependappend-anti-pattern"></a>先頭または末尾に追加するアンチパターン
大量に挿入する場合に、挿入を複数のパーティションに分散させることで、スケーラビリティを向上させます。  

#### <a name="context-and-problem"></a>コンテキストと問題
格納されているエンティティの先頭または末尾にエンティティを追加すると、通常は、連続するパーティションの最初または最後のパーティションに新しいエンティティが追加されます。 この場合、常に挿入はすべて同じパーティション内で行われるため、ホットスポットが発生し、Table サービスが複数のノードに挿入の負荷を分散できず、場合によっては、パーティションのスケーラビリティ ターゲットに達する可能性があります。 たとえば、従業員によるネットワークやリソースへのアクセスをログに記録するアプリケーションで、以下に示すエンティティ構造を使用した場合、トランザクションの量が個々のパーティションのスケーラビリティ ターゲットに達すると、現在処理が行われているパーティションがホットスポットになる可能性があります。  

![][26]

#### <a name="solution"></a>解決策
代わりに次のエンティティ構造を使用すると、アプリケーションでイベントをログに記録する際に特定のパーティションのホットスポットを回避できます。  

![][27]

次の例では 2 つのキー **PartitionKey** と **RowKey** がどのように複合キーになっているか注意してください。 **PartitionKey** は部署と従業員の両方の ID を使用して複数のパーティションにログを配布します。  

#### <a name="issues-and-considerations"></a>問題と注意事項
このパターンの実装方法を決めるときには、以下の点に注意してください。  

* 挿入時のホット パーティションの発生を回避する代わりのキー構造でクライアント アプリケーションが実行するクエリを効率的にサポートしていますか。  
* 予想されるトランザクションの量から判断して、個々のパーティションのスケーラビリティ ターゲットに達し、ストレージ サービスによって調整される可能性がありますか。  

#### <a name="when-to-use-this-pattern"></a>このパターンを使用する状況
トランザクションの量により、ホット パーティションにアクセスするとストレージ サービスによってレート制限される可能性がある場合は、先頭または末尾に追加するアンチパターンを使用しないでください。  

#### <a name="related-patterns-and-guidance"></a>関連のあるパターンとガイダンス
このパターンを実装する場合は、次のパターンとガイダンスも関連している可能性があります。  

* [複合キー パターン](#compound-key-pattern)  
* [ログ テールパターン](#log-tail-pattern)  
* [エンティティの変更](#modifying-entities)  

### <a name="log-data-anti-pattern"></a>ログ データのアンチパターン
ログ データの格納には通常、Table service ではなく Blob service を使用します。  

#### <a name="context-and-problem"></a>コンテキストと問題
ログ データを使用する局面として最も一般的なのが、特定の日付範囲または時間範囲のログ エントリを選択して取得するというものです。たとえば、特定の日の 15:04 から 15:06 までの間にアプリケーションが記録したエラー メッセージや重要なメッセージをすべて取得するなどの局面が挙げられます。 ログ メッセージの日時を使用して、ログのエンティティを保存するパーティションを特定したくない場合は、ホット パーティションになります。任意の時点で、すべてのログ エンティティが同じ **PartitionKey** 値を共有します ([先頭または末尾に追加するアンチ パターン](#prepend-append-anti-pattern)のセクションをご覧ください)。 たとえば、ログ メッセージに関する以下のエンティティ スキーマでは、アプリケーションが現在の日付や時刻についてパーティションにあらゆるログ メッセージを書き込むことになるため、ホット パーティションの問題が発生します。  

![][28]

この例では、 **RowKey** にはログ メッセージが日時順で格納されていることを確認するため、ログメッセージの日時が含まれており、複数のメッセージが同じ日時を共有する複数のログ メッセージの場合にはメッセージ ID も含まれています。  

別の方法は、アプリケーションに確実に パーティション範囲にわたってメッセージを書き込ませる **PartitionKey** の使用です。 たとえば、ログ メッセージのソースで多数のパーティションにメッセージを配信できるようになっている場合には、以下のエンティティ スキーマを使用できます。  

![][29]

ただし、このスキーマには問題があります。特定のタイム スパンに記録されたログ メッセージをすべて取得するときには、テーブル内のパーティションを逐一検索する必要があるからです。

#### <a name="solution"></a>解決策
前のセクションでは、ログ エントリの保存先として Table service を使用した場合に生じる問題について説明し、その解決策として、完璧とは言いがたいものの 2 つの設計を紹介しました。 1 つ目に紹介した方法には、ホット パーティションが発生し、ログ メッセージの書き込みのパフォーマンスが低下するリスクがあります。これに対して 2 つ目の方法は、特定のタイム スパンについてログ メッセージを取得しようとした場合に、テーブル内のパーティションを逐一スキャンしなければならないため、クエリのパフォーマンスが低下するという問題がありました。 BLOB ストレージなら、ここで取り上げたシナリオについて前の 2 つよりも優れたソリューションとなることができます。このため、Azure Storage Analytics が収集したログ データを保存するときにも、この BLOB ストレージが使用されています。  

このセクションでは、Storage Analytics が BLOB ストレージにログ データを格納する流れの概要を説明し、範囲を指定してクエリを実行することが多いデータを保存する際にこのアプローチがどのように役立つかを見ていきます。  

Storage Analytics では、ログ メッセージを一定の形式で区切ったものを、複数の BLOB に格納します。 区切りに使用する形式は、クライアント アプリケーション側でログ メッセージのデータ解析を円滑に完了できるものになっています。  

Storage Analytics が BLOB に対して使用している名前付け規則は、検索対象のログ メッセージが含まれる BLOB の場所を特定できるようなものになっています。 たとえば、"queue/2014/07/31/1800/000001.log" という名前の BLOB であれば、2014 年 7 月 31 日の 18:00 から始まる時間の Queue サービスと関係があるログ メッセージが格納されています。 "000001" という部分は、この期間の最初のログ ファイルであることを示しています。 このほか、Storage Analytics では BLOB のメタデータの一環として、ファイルに保存されている最初と最後のログ メッセージのタイムスタンプを記録します。 BLOB ストレージの API では、一定の名前プレフィックスに基づいてコンテナー内の BLOB の場所を特定できるようになっています。18:00 から始まる時間についてキューのログ データを格納している BLOB をすべて検索する場合には、"queue/2014/07/31/1800" というプレフィックスを使用します。  

Storage Analytics は内部のバッファーにログ メッセージを保管したうえで、ログ エントリのバッチの最新版を使って定期的に BLOB を更新したり、新しい BLOB を作成したりします。 これによって、BLOB サービスに書き込みを実行する回数が少なくなります。  

アプリケーションにこれと似たソリューションを実装するときには、信頼性 (ログ エントリが発生するたびに BLOB ストレージに書き込む) と、コストとスケーラビリティ (アプリケーションに更新内容を一時的に保管し、バッチとして BLOB ストレージに書き込む) との間のトレードオフをどのようにするかについて、検討が必要になります。  

#### <a name="issues-and-considerations"></a>問題と注意事項
ログ データの保存方法を決めるときには、以下の点に注意する必要があります。  

* ホット パーティションが発生しないような設計のテーブルを作成すると、ログ データに対するアクセス効率が低下することがあります。  
* ログ データを処理するときには多くの場合、クライアント側で多くのレコードを読み込む必要があります。  
* ログ データは構造化されていないことが多いものの、BLOB ストレージの方が優れたソリューションになることがあります。  

### <a name="implementation-considerations"></a>実装時の注意事項
このセクションでは、ここまでのセクションで説明したパターンを実装する際に念頭に置く必要がある点をいくつか説明します。 このセクションで示したコード例は、ほとんどが C# で書かれ、ストレージ クライアント ライブラリ (本稿執筆時点のバージョンは 4.3.0) を使用しています。  

### <a name="retrieving-entities"></a>エンティティの取得
「 [クエリに対応した設計](#design-for-querying)」で説明したように、最も効率的なクエリはポイント クエリです。 ただ、時として多数のエンティティを同時に取得することも必要になります。 このセクションでは、ストレージ クライアント ライブラリを使ってエンティティを取得するときによく使用される方法をいくつか紹介します。  

#### <a name="executing-a-point-query-using-the-storage-client-library"></a>ストレージ クライアント ライブラリを使ってポイント クエリを実行する
ポイント クエリを実行する最も簡単な方法は、次の c# コード スニペットに表示された、**PartitionKey** 値 "Sales" と **RowKey** 値 "212" を持つエンティティを取得する**取得** テーブル操作の使用です。  

```csharp
TableOperation retrieveOperation = TableOperation.Retrieve<EmployeeEntity>("Sales", "212");
var retrieveResult = employeeTable.Execute(retrieveOperation);
if (retrieveResult.Result != null)
{
    EmployeeEntity employee = (EmployeeEntity)retrieveResult.Result;
    ...
}  
```

この例では、 **従業員エンティティ**型のエンティティを取得することをどのように予想しているか注意してください。  

#### <a name="retrieving-multiple-entities-using-linq"></a>LINQ を使用して複数のエンティティを取得します。
複数のエンティティを取得するには、て、ストレージ クライアント ライブラリとともにLINQ を使用し、 **where** 句のあるクエリを指定します。 テーブル スキャンを回避するのには、where 句の **PartitionKey** 値と、可能であれば **RowKey** 値をインクルードし、テーブルとパーティションのスキャンを避けます。 Table サービスは、where 句で一部の比較演算子 (より大きい、以上、より小さい、以下、等しい、等しくない) のみサポートしています。 次の c# のコード スニペットは、Sales 部署 (**PartitionKey** が部署名を格納していると仮定) の中で、姓が "B" (**RowKey** が姓を格納していると仮定) で始まるすべての従業員を検索 します。  

```csharp
TableQuery<EmployeeEntity> employeeQuery = employeeTable.CreateQuery<EmployeeEntity>();
var query = (from employee in employeeQuery
            where employee.PartitionKey == "Sales" &&
            employee.RowKey.CompareTo("B") >= 0 &&
            employee.RowKey.CompareTo("C") < 0
            select employee).AsTableQuery();
var employees = query.Execute();  
```

パフォーマンスを確保するため、クエリで **RowKey** と **PartitionKey** の両方をどのように指定するか注意してください。  

次のコード サンプルは、Fluent API を使用したのと同等の機能を示しています (一般的な Fluent API の詳細について、 [Fluent API を設計するためのベスト プラクティス](http://visualstudiomagazine.com/articles/2013/12/01/best-practices-for-designing-a-fluent-api.aspx)を参照してください)。  

```csharp
TableQuery<EmployeeEntity> employeeQuery = new TableQuery<EmployeeEntity>().Where(
    TableQuery.CombineFilters(
    TableQuery.CombineFilters(
        TableQuery.GenerateFilterCondition(
    "PartitionKey", QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.GenerateFilterCondition(
    "RowKey", QueryComparisons.GreaterThanOrEqual, "B")
),
TableOperators.And,
TableQuery.GenerateFilterCondition("RowKey", QueryComparisons.LessThan, "C")
    )
);
var employees = employeeTable.ExecuteQuery(employeeQuery);  
```

> [!NOTE]
> このサンプルでは、 3 つのフィルター条件を含んだ複数の **コンバイン フィルター** メソッドをネストしています。  
> 
> 

#### <a name="retrieving-large-numbers-of-entities-from-a-query"></a>1 件のクエリで大量のエンティティを取得する
最適なクエリは **PartitionKey** 値と **RowKey** 値に基づいて個別のエンティティを返します。 ところが、場合によっては同じパーティション、ときには多数のパーティションから、多数のエンティティを返すことが必要になります。  

そのようなときには必ず、アプリケーションのパフォーマンスを綿密にテストする必要があります。  

Table サービスに対してクエリを実行した場合、一度に返されるエンティティの数は最大 1,000 件、クエリの実行時間は最大 5 秒間です。 結果として返されるエンティティが 1,000 件を超える場合、クエリが 5 秒以内に完了しなかった場合、またはクエリがパーティションの境界をまたいで実行される場合には、Table service によって継続トークンが返されます。クライアント アプリケーションはこのトークンを使って、続きとなるエンティティを要求します。 継続トークンの詳細については、「[クエリのタイムアウトと改ページ](http://msdn.microsoft.com/library/azure/dd135718.aspx)」をご覧ください。  

ストレージ クライアント ライブラリを使用している場合には、Table service からエンティティが返されるたびに継続トークンが自動で処理されます。 以下の C# コード サンプルではストレージ クライアント ライブラリを使用しているため、Table サービスが応答で返した継続トークンが自動的に処理されます。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

var employees = employeeTable.ExecuteQuery(employeeQuery);
foreach (var emp in employees)
{
        ...
}  
```

以下の C# コード サンプルでは、継続トークンの処理を明示的に記述しています。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

TableContinuationToken continuationToken = null;

do
{
        var employees = employeeTable.ExecuteQuerySegmented(
        employeeQuery, continuationToken);
    foreach (var emp in employees)
    {
    ...
    }
    continuationToken = employees.ContinuationToken;
} while (continuationToken != null);  
```

継続トークンを明示的に使用すると、アプリケーションが次のセグメントに相当するデータを取得するタイミングを制御ができます。 たとえば、テーブルに格納されたエンティティをクライアント アプリケーションでページとして表示できるようにしている場合に、クエリで取得したエンティティをユーザーが最後まで見ないことがあります。そのようなとき、継続トークンを明示的に使用していれば、ユーザーが現在のセグメントのエンティティの最後のページに達した時点で、アプリケーションが継続トークンだけを使って次のセグメントを取得できます。 この方法には、いくつかの利点があります。  

* Table service から取得するデータの量を制限したり、ユーザーがネットワークを移動したりできるようになります。  
* .NET の非同期 IO を実行できるようになります。  
* 継続トークンをシリアル化して永続記憶装置に保存できるため、アプリケーションがクラッシュした場合でも処理を継続できるようになります。  

> [!NOTE]
> 継続トークンは通常、エンティティ 1,000 件を 1 つのセグメントにして返しますが、この数が少なくなることもあります。 これも、**取得**を使用してクエリが返すをエントリの数を制限する場合は、検索条件に一致する最初の n 件のエンティティを返します。テーブル サービスは、残りのエンティティを取得するため、継続トークンと合わせて n 件より少ないエンティティを含むセグメントを返す可能性があります。  
> 
> 

以下の C# コードは、1 つのセグメントで返されるエンティティの数を変更するためのものです。  

```csharp
employeeQuery.TakeCount = 50;  
```

#### <a name="server-side-projection"></a>サーバー側のプロジェクション
1 つのエンティティには最大で 255 個のプロパティを格納でき、エンティティの最大サイズは 1 MB です。 テーブルに対してクエリを実行してエンティティを取得する際、すべてのプロパティが必要ない場合は、データの不要な転送を避けることができます (遅延とコストの削減につながります)。 サーバー側のプロジェクションを使えば、必要なプロパティのみを転送できます。 次の例は、クエリによって選択されたエンティティから **Email** プロパティ (**PartitionKey**、**RowKey**、**Timestamp**、**ETag** と連動) を取得しています。  

```csharp
string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
List<string> columns = new List<string>() { "Email" };
TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter).Select(columns);

var entities = employeeTable.ExecuteQuery(employeeQuery);
foreach (var e in entities)
{
        Console.WriteLine("RowKey: {0}, EmployeeEmail: {1}", e.RowKey, e.Email);
}  
```

**RowKey** 値は取得するプロパティのリストに含まれていなくてもどのように有効であることか注意してください。  

### <a name="modifying-entities"></a>エンティティの変更
ストレージ クライアント ライブラリを使えば、Table サービスに格納されたエンティティを、挿入、削除、更新の各操作によって変更できます。 また、EGT を使えば複数の挿入、更新、削除の操作をバッチ処理で行えるため、必要なラウンド トリップの回数が減り、ソリューションのパフォーマンスが高まります。  

ストレージ クライアント ライブラリが EGT を実行したときにスローされる例外には、通常、バッチ処理の失敗を招いたエンティティのインデックスが含まれます。 これは EGT を使うコードをデバッグする際に役立ちます。  

クライアント アプリケーションでの同時実行と更新操作の処理方法に設計が及ぼす影響についても考慮が必要です。  

#### <a name="managing-concurrency"></a>同時実行を管理する
既定では、テーブル サービスは個々 のエンティティのレベルで**挿入**、**マージ**、**削除**操作に対しオプティミスティック同時実行チェックを実行しますが、クライアントは、テーブル サービスがこれらのチェックをバイパスするよう強制することもできます。 Table service での同時実行の管理方法については、「[Microsoft Azure Storage での同時実行制御の管理](../storage/common/storage-concurrency.md)」をご覧ください。  

#### <a name="merge-or-replace"></a>マージまたは置換
**TableOperation** クラスの**置換**のメソッドは、常に、Table service の完全なエンティティを置換します。 格納されたエンティティに存在するプロパティを要求に含めない場合、要求により、格納されたエンティティからそのプロパティが削除されます。 格納されたエンティティからプロパティを明示的に削除しない場合は、すべてのプロパティを要求に含める必要があります。  

**TableOperation** クラスの**マージ** メソッドを使用して エンティティを更新するときの Table service に送信するデータの量を削減します。 **マージ** メソッドはプロパティ値を持った格納エンティティのプロパティをリクエストに含まれるエンティティと置換しますが、リクエストに含まれない格納エンティティ内の無傷のプロパティはそのまま残します。 ラージ エンティティがあり、要求で少数のプロパティのみを更新する必要があるときに便利な処理です。  

> [!NOTE]
> エンティティが存在しない場合、**置換**と**マージ** メソッドが失敗します。 存在しない場合は、代わりに、**InsertOrReplace** と **InsertOrMerge** メソッドを使用して新しいエンティティを作成します。  
> 
> 

### <a name="working-with-heterogeneous-entity-types"></a>異種のエンティティ種類の使用
Table service とは、*スキーマのない* テーブル ストアを 1 つのテーブルが非常に柔軟にデザインを提供する複数の種類のエンティティを格納できることを意味します。 次の例は、従業員エンティティと部署エンティティの両方を格納したテーブルを示しています。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

各エンティティはなお、**PartitionKey**、**RowKey**、**Timestamp** 値を持つ必要がありますが、プロパティ セットを持つ場合もあります。 さらに、エンティティの種類を示すものがありません (エンティティの種類に関する情報を格納していない場合)。 エンティティの種類を識別する方法は 2 とおりあります。  

* **RowKey** (または **PartitionKey**) にエンティティ型を追加。 例えば、**RowKey** 値としての**EMPLOYEE_000123** または **DEPARTMENT_SALES**。  
* 以下の表に示すように、個別のプロパティを使用してエンティティの種類を記録します。  

<table>
<tr>
<th>パーティション キー</th>
<th>行キー</th>
<th>Timestamp</th>
<th></th>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>DepartmentName</th>
<th>EmployeeCount</th>
</tr>
<tr>
<td>部署</td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>
<table>
<tr>
<th>EntityType</th>
<th>FirstName</th>
<th>LastName</th>
<th>Age</th>
<th>電子メール</th>
</tr>
<tr>
<td>Employee</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</table>
</td>
</tr>
</table>

最初のオプションでは、エンティティ型を **RowKey**の先頭に着けると、異なる種類の 2 つのエンティティが同じキー値にある可能性がある場合に便利です。 この方法なら、パーティションに同じ種類のエンティティのグループ化もできます。  

このセクションで説明した手法は特に、本ガイドに前述の[リレーションシップのモデリング](#modelling-relationships) セクション内の[継承リレーションシップ](#inheritance-relationships)で説明した内容と関連がありま す。  

> [!NOTE]
> エンティティの種類の値にバージョン番号を追加して、クライアント アプリケーションで POCO オブジェクトを発展させ、さまざまなバージョンを操作できるようにすることを検討してください。  
> 
> 

このセクションの残りの部分では、同じテーブル内の異なる種類のエンティティを操作しやすくするストレージ クライアント ライブラリの機能について説明します。  

#### <a name="retrieving-heterogeneous-entity-types"></a>異なる種類のエンティティを取得する
ストレージ クライアント ライブラリを使えば、3 とおりの方法で複数の種類のエンティティを操作できます。  

特定の **RowKey** および **PartitionKey** 値とともに格納されているエンティティの型がわかっている場合は、**EmployeeEntity** 型のエンティティを取得する前述の 2 つの例 (「[ストレージ クライアント ライブラリを使ってポイント クエリを実行する](#executing-a-point-query-using-the-storage-client-library)」および「[LINQ を使って複数のエンティティを取得する](#retrieving-multiple-entities-using-linq)」) に示すように、エンティティを取得する際にエンティティの型を指定できます。  

2 番目のオプションは、具体的な POCO エンティティ型の代わりに **DynamicTableEntity** 型  (プロパティ バッグ) の使用です(エンティティを .NET 型にシリアル化および非シリアル化する必要がないため、このオプションはパフォーマンスも向上させます) 。 次の c# コードは、テーブルから潜在的にさまざまな種類の複数のエンティティを取得しますが、すべてのエンティティを **DynamicTableEntity** インスタンスとして返します。 **EntityType** プロパティを使用して各エンティティの種類を決定します。  

```csharp
string filter = TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("PartitionKey",
    QueryComparisons.Equal, "Sales"),
    TableOperators.And,
    TableQuery.CombineFilters(
    TableQuery.GenerateFilterCondition("RowKey",
                    QueryComparisons.GreaterThanOrEqual, "B"),
        TableOperators.And,
        TableQuery.GenerateFilterCondition("RowKey",
        QueryComparisons.LessThan, "F")
    )
);
TableQuery<DynamicTableEntity> entityQuery =
    new TableQuery<DynamicTableEntity>().Where(filter);
var employees = employeeTable.ExecuteQuery(entityQuery);

IEnumerable<DynamicTableEntity> entities = employeeTable.ExecuteQuery(entityQuery);
foreach (var e in entities)
{
EntityProperty entityTypeProperty;
if (e.Properties.TryGetValue("EntityType", out entityTypeProperty))
{
    if (entityTypeProperty.StringValue == "Employee")
    {
        // Use entityTypeProperty, RowKey, PartitionKey, Etag, and Timestamp
        }
    }
}  
```

その他のプロパティを取得するには、**DynamicTableEntity** クラスの **Properties** プロパティ上にある **TryGetValue** メソッドを使用する必要があります。  

3 番目のオプションは、**DynamicTableEntity** 型と **EntityResolver** インスタンスの組み合わせの使用です。 この方法なら、同じクエリで複数の POCO 型を解決できます。 この例では、**EntityResolver** デリゲートは **EntityType** プロパティを使用して、クエリによって返されるエンティティの 2 つの種類を区別します。 **Resolve** メソッドは、**resolver** デリゲートを使用して **DynamicTableEntity** インスタンスを **TableEntity** インスタンスに解決します。  

```csharp
EntityResolver<TableEntity> resolver = (pk, rk, ts, props, etag) =>
{

        TableEntity resolvedEntity = null;
        if (props["EntityType"].StringValue == "Department")
        {
        resolvedEntity = new DepartmentEntity();
        }
        else if (props["EntityType"].StringValue == "Employee")
        {
        resolvedEntity = new EmployeeEntity();
        }
        else throw new ArgumentException("Unrecognized entity", "props");

        resolvedEntity.PartitionKey = pk;
        resolvedEntity.RowKey = rk;
        resolvedEntity.Timestamp = ts;
        resolvedEntity.ETag = etag;
        resolvedEntity.ReadEntity(props, null);
        return resolvedEntity;
};

string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, "Sales");
TableQuery<DynamicTableEntity> entityQuery =
        new TableQuery<DynamicTableEntity>().Where(filter);

var entities = employeeTable.ExecuteQuery(entityQuery, resolver);
foreach (var e in entities)
{
        if (e is DepartmentEntity)
        {
    ...
        }
        if (e is EmployeeEntity)
        {
    ...
        }
}  
```

#### <a name="modifying-heterogeneous-entity-types"></a>異なる種類のエンティティを変更する
エンティティの種類がわからなくても削除はできますが、挿入はできません。 ですが、種類がわからなくても、POCO エンティティ クラスを使用せず、 **DynamicTableEntity** 型を使用して エンティティを更新します。 次のコード サンプルでは、1 つのエンティティを取得し、 **EmployeeCount** プロパティが存在するか、更新前に確認しています。  

```csharp
TableResult result =
        employeeTable.Execute(TableOperation.Retrieve(partitionKey, rowKey));
DynamicTableEntity department = (DynamicTableEntity)result.Result;

EntityProperty countProperty;

if (!department.Properties.TryGetValue("EmployeeCount", out countProperty))
{
        throw new
        InvalidOperationException("Invalid entity, EmployeeCount property not found.");
}
countProperty.Int32Value += 1;
employeeTable.Execute(TableOperation.Merge(department));  
```

### <a name="controlling-access-with-shared-access-signatures"></a>共有アクセス署名でのアクセスを制御する
Shared Access Signature (SAS) トークンを使うと、クライアント アプリケーションで、Table サービスに対して直接認証しなくてもテーブル エンティティを直接変更 (と照会) できるようになります。 通常、アプリケーションで SAS を使うと、次の 3 つのメリットが得られます。  

* デバイスで Table service のエンティティにアクセスして変更できるようにするために、安全ではないプラットフォーム (モバイル デバイスなど) にストレージ アカウント キーを配布する必要がない。  
* Web ロールまたは worker ロールがエンティティを管理する際に実行する処理の一部を、エンド ユーザー コンピューターやモバイル デバイスなどのクライアント デバイスにオフロードできる。  
* 制約と時間制限のあるアクセス許可のセットをクライアントに割り当てることができる (読み取り専用アクセスを特定のリソースに許可するなど)。  

Table service での SAS トークンの使用について詳しくは、「 [Shared Access Signatures (SAS) の使用](../storage/common/storage-dotnet-shared-access-signature-part-1.md)」をご覧ください。  

ただし、Table service 内のエンティティへのアクセス権をクライアント アプリケーションに付与する SAS トークンを生成する必要はあります。これは、ストレージ アカウント キーに安全にアクセスできる環境で行うようにしてください。 通常は、Web ロールまたは worker ロールを使って SAS トークンを生成し、エンティティへのアクセスを必要とするクライアント アプリケーションに配布します。 SAS トークンの生成とクライアントへの配布にもやはりオーバーヘッドが伴うため、特に大量に扱うシナリオでは、このオーバーヘッドを減らす最適な方法を検討する必要があります。  

テーブル内のエンティティのサブセットへのアクセスを付与する SAS トークンを生成できます。 既定では、テーブル全体に対し SAS トークンを作成しますが、SAS トークンへのアクセス許可を **PartitionKey** 値の範囲か、**PartitionKey** と **RowKey** 値の範囲のいずれかに指定することも可能です。 システムの個々のユーザーに SAS トークンが生成されるようにすれば、各ユーザーの SAS トークンによってアクセスが許可されるのは、Table サービス内にあるユーザー独自のエンティティだけになります。  

### <a name="asynchronous-and-parallel-operations"></a>非同期と並列操作
要求を複数のパーティションに分散させている場合は、非同期または並列クエリを使ってスループットとクライアントの応答性を向上させることができます。
たとえば、テーブルに並列的にアクセスする複数の worker ロール インスタンスを使用する場合などです。 個別の worker ロールで特定のパーティション セットのみを処理することも可能であるほか、テーブル内のすべてのパーティションにアクセスできる worker ロール インスタンスを複数実装することも可能です。  

クライアント インスタンスでは、ストレージ操作を非同期的に実行することでスループットを高めることができます。 ストレージ クライアント ライブラリを使えば、非同期クエリと変更を簡単に記述できます。 たとえば、次の C# コードに示すように、パーティション内のすべてのエントリを取得する同期メソッドをベースとして利用できます。  

```csharp
private static void ManyEntitiesQuery(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);

        TableContinuationToken continuationToken = null;

        do
        {
        var employees = employeeTable.ExecuteQuerySegmented(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
    {
        ...
    }
        continuationToken = employees.ContinuationToken;
        } while (continuationToken != null);
}  
```

このコードを次のように少し変更して、クエリが非同期的に実行されるようにします。  

```csharp
private static async Task ManyEntitiesQueryAsync(CloudTable employeeTable, string department)
{
        string filter = TableQuery.GenerateFilterCondition(
        "PartitionKey", QueryComparisons.Equal, department);
        TableQuery<EmployeeEntity> employeeQuery =
        new TableQuery<EmployeeEntity>().Where(filter);
        TableContinuationToken continuationToken = null;

        do
        {
        var employees = await employeeTable.ExecuteQuerySegmentedAsync(
                employeeQuery, continuationToken);
        foreach (var emp in employees)
        {
            ...
        }
        continuationToken = employees.ContinuationToken;
            } while (continuationToken != null);
}  
```

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

* メソッドのシグネチャは **async** 修飾子を含み、**Task** インスタンスを返します。  
* **ExecuteSegmented** メソッドを呼び出して結果を取得する代わりに、**ExecuteSegmentedAsync** メソッドを呼び出し、**await** 修飾子を使用して非同期的に結果を取得します。  

クライアント アプリケーションが複数回このメソッドを呼び出し ( **部署** パラメーターの異なる値のため)、各クエリは個別のスレッドで実行されます。  

**IEnumerable** インターフェイスは非同期列挙型をサポートしていないため、**TableQuery** クラス内の**Execute** メソッドには非同期バージョンはありません。  

エンティティを非同期的に挿入、更新、削除できます。 次の C# の例は、従業員エンティティを挿入または置換する単純な同期メソッドです。  

```csharp
private static void SimpleEmployeeUpsert(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = employeeTable
        .Execute(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

このコードを次のように少し変更して、更新が非同期的に実行されるようにすることができます。  

```csharp
private static async Task SimpleEmployeeUpsertAsync(CloudTable employeeTable,
        EmployeeEntity employee)
{
        TableResult result = await employeeTable
        .ExecuteAsync(TableOperation.InsertOrReplace(employee));
        Console.WriteLine("HTTP Status: {0}", result.HttpStatusCode);
}  
```

この非同期の例は、同期のバージョンに次の変更が加えられたものです。  

* メソッドのシグネチャは **async** 修飾子を含み、**Task** インスタンスを返します。  
* **Execute** メソッドを呼び出してエンティティを更新する代わりに、**ExecuteAsync** メソッドを呼び出し、**await** 修飾子を使用して非同期的に結果を取得します。  

クライアント アプリケーションは、これと同じように非同期メソッドを複数回呼び出すことができます。各メソッドの呼び出しは別々のスレッドで実行されます。  

### <a name="credits"></a>謝辞
投稿していただいた Microsoft DX の Tom Hollander 氏、および Azure チームのメンバーである Dominic Betts、Jason Hogg、Jean Ghanem、Jai Haridas、Jeff Irwin、Vamshidhar Kommineni、Vinay Shah、Serdar Ozler の各氏に感謝の意を表します。 

また、レビュー時に貴重なご意見をいただいた Microsoft MVP の Igor Papirov および Edward Bakker の両氏にも感謝いたします。

[1]: ./media/storage-table-design-guide/storage-table-design-IMAGE01.png
[2]: ./media/storage-table-design-guide/storage-table-design-IMAGE02.png
[3]: ./media/storage-table-design-guide/storage-table-design-IMAGE03.png
[4]: ./media/storage-table-design-guide/storage-table-design-IMAGE04.png
[5]: ./media/storage-table-design-guide/storage-table-design-IMAGE05.png
[6]: ./media/storage-table-design-guide/storage-table-design-IMAGE06.png
[7]: ./media/storage-table-design-guide/storage-table-design-IMAGE07.png
[8]: ./media/storage-table-design-guide/storage-table-design-IMAGE08.png
[9]: ./media/storage-table-design-guide/storage-table-design-IMAGE09.png
[10]: ./media/storage-table-design-guide/storage-table-design-IMAGE10.png
[11]: ./media/storage-table-design-guide/storage-table-design-IMAGE11.png
[12]: ./media/storage-table-design-guide/storage-table-design-IMAGE12.png
[13]: ./media/storage-table-design-guide/storage-table-design-IMAGE13.png
[14]: ./media/storage-table-design-guide/storage-table-design-IMAGE14.png
[15]: ./media/storage-table-design-guide/storage-table-design-IMAGE15.png
[16]: ./media/storage-table-design-guide/storage-table-design-IMAGE16.png
[17]: ./media/storage-table-design-guide/storage-table-design-IMAGE17.png
[18]: ./media/storage-table-design-guide/storage-table-design-IMAGE18.png
[19]: ./media/storage-table-design-guide/storage-table-design-IMAGE19.png
[20]: ./media/storage-table-design-guide/storage-table-design-IMAGE20.png
[21]: ./media/storage-table-design-guide/storage-table-design-IMAGE21.png
[22]: ./media/storage-table-design-guide/storage-table-design-IMAGE22.png
[23]: ./media/storage-table-design-guide/storage-table-design-IMAGE23.png
[24]: ./media/storage-table-design-guide/storage-table-design-IMAGE24.png
[25]: ./media/storage-table-design-guide/storage-table-design-IMAGE25.png
[26]: ./media/storage-table-design-guide/storage-table-design-IMAGE26.png
[27]: ./media/storage-table-design-guide/storage-table-design-IMAGE27.png
[28]: ./media/storage-table-design-guide/storage-table-design-IMAGE28.png
[29]: ./media/storage-table-design-guide/storage-table-design-IMAGE29.png

